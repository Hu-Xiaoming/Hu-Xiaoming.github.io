<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ubuntu创建快捷方式</title>
    <link href="/2022/06/13/ubuntu%E5%88%9B%E5%BB%BA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/06/13/ubuntu%E5%88%9B%E5%BB%BA%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Creating-Shortcuts-Under-Ubuntu"><a href="#Creating-Shortcuts-Under-Ubuntu" class="headerlink" title="Creating Shortcuts Under Ubuntu"></a>Creating Shortcuts Under Ubuntu</h1><blockquote><p>Author: HuXiaoming<br>Date: 2022-06-13</p></blockquote><h2 id="What-Is-It-amp-amp-Why"><a href="#What-Is-It-amp-amp-Why" class="headerlink" title="What Is It &amp;&amp; Why?"></a>What Is It &amp;&amp; Why?</h2><p>I used to install software with <code>.deb</code> file under Ubuntu, which can create a shortcut automatically. However, sometimes we have to use other ways to install software, (e.g., downloading the compressed package of the software.) and it don’t create a shortcut automatically. So we have to create a shortcut manually if we don’t want to open the software in a troublesome way.</p><h2 id="How-To-Create-A-Shortcut"><a href="#How-To-Create-A-Shortcut" class="headerlink" title="How To Create A Shortcut?"></a>How To Create A Shortcut?</h2><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><blockquote><p>We download the software of webots and create a shortcut for it as an example.</p></blockquote><h4 id="Download-amp-amp-Extract"><a href="#Download-amp-amp-Extract" class="headerlink" title="Download &amp;&amp; Extract"></a>Download &amp;&amp; Extract</h4><p>We go to the  <a href="https://github.com/cyberbotics/webots/releases/tag/R2022a">link</a> to download the compressed package <code>webots-R2022a-x86-64_ubuntu-18.04.tar.bz2</code> of webots software, and then extract it in your <code>home</code> folder.</p><h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><p>We open the <code>webots</code> folder in terminal, and run this command <code>./webots</code> to test whether we can open webots software in terminal.</p><h4 id="Create-A-Shortcut"><a href="#Create-A-Shortcut" class="headerlink" title="Create A Shortcut"></a>Create A Shortcut</h4><p>We open a new terminal, and run this command <code>cd /usr/share/applications</code>. In the <code>applications</code> folder, you will find a lot of <code>.desktop</code> files for your installed software. Than, we should run <code>vim webots.desktop</code> and type the following: </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Name</span>=webots<br><span class="hljs-attr">Comment</span>=webots IDE<br><span class="hljs-attr">Exec</span>=/home/hu/webots/webots<br><span class="hljs-attr">Icon</span>=/home/hu/webots/resources/icons/core/webots.png<br><span class="hljs-attr">Terminal</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">Type</span>=Application<br><span class="hljs-attr">StartupNotify</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">Categories</span>=Application<span class="hljs-comment">;Development;</span><br></code></pre></td></tr></table></figure><p><code>Exec</code> is the path of your executable file (the file is a executable file in the command <code>./webots</code> in the subtitle <strong>Run</strong>).</p><p><code>Tcon</code> is the path of the icons for your software.</p><h4 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h4><p>After that, you will find the shortcut of webots in your <code>show application</code> (bottom left corner of screen).</p>]]></content>
    
    
    
    <tags>
      
      <tag>webots</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyCharm中Python Interprets的配置</title>
    <link href="/2022/04/12/PyCharm%E4%B8%ADPython-Interprets%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/04/12/PyCharm%E4%B8%ADPython-Interprets%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="PyCharm中Python-Interprets的配置"><a href="#PyCharm中Python-Interprets的配置" class="headerlink" title="PyCharm中Python Interprets的配置"></a>PyCharm中Python Interprets的配置</h1><div class="note note-info">            <p>本文<strong>转载</strong>自CSDN，原文标题为：<a href="https://blog.csdn.net/qq_41498261/article/details/109112331">详细了解PyCharm支持的4种Python Interpreter和配置方法</a></p>          </div><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>初次使用Pycharm的时候，可能会对于解释器的配置有些疑问，因为PyCharm支持以下4种Python Interpreter:</p><ul><li>Virtualenv Environment</li><li>Conda Environment</li><li>System Interpreter</li><li>Pipenv Environment</li></ul><h2 id="1-Virtualenv-Environment"><a href="#1-Virtualenv-Environment" class="headerlink" title="1 Virtualenv Environment"></a>1 Virtualenv Environment</h2><h3 id="1-1-Virtualenv-Environment是什么？"><a href="#1-1-Virtualenv-Environment是什么？" class="headerlink" title="1.1 Virtualenv Environment是什么？"></a>1.1 Virtualenv Environment是什么？</h3><p>Python的虚拟环境可以使一个Python程序拥有独立的库(<strong>library</strong>)和解释器(<strong>interpreter</strong>)，而不用与其他Python程序共享同一个library和interpreter。虚拟环境的好处是避免了不同Python程序间的互相影响（共同使用全局的(<strong>global</strong>) library 和 interpreter），例如程序A需要某个库的1.0版本，而程序B需要同样这个库的2.0版本，如果程序B执行，则A就不能执行了。</p><blockquote><p>virtualenv，是一款Python工具，用以创建独立的Python虚拟环境。在一个Python虚拟环境中，持有Python所必须的依赖库，形成Python的虚拟运行空间。</p></blockquote><p>Pycharm中集成了Virtual Environment工具，用以创建独立的虚拟环境。</p><p>Virtual Environment主要解决的库依赖和版本依赖、以及间接授权等问题。</p><h3 id="1-2-如何使用Virtualenv-Environment？"><a href="#1-2-如何使用Virtualenv-Environment？" class="headerlink" title="1.2 如何使用Virtualenv Environment？"></a>1.2 如何使用Virtualenv Environment？</h3><p>打开Pycharm的Virtualenv Environment配置界面，发现存在两种配置方式：</p><p><img src="/2022/04/12/PyCharm%E4%B8%ADPython-Interprets%E7%9A%84%E9%85%8D%E7%BD%AE/Virtualenv_Environment%E9%85%8D%E7%BD%AE%E7%95%8C%E9%9D%A2.png" alt="图1 Virtualenv Environment配置界面"></p><h4 id="1-2-1-New-environment"><a href="#1-2-1-New-environment" class="headerlink" title="1.2.1 New environment"></a>1.2.1 New environment</h4><p><img src="/2022/04/12/PyCharm%E4%B8%ADPython-Interprets%E7%9A%84%E9%85%8D%E7%BD%AE/new_environment%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图2 new environment方式配置示意图"></p><p>需要配置的项：</p><ul><li><p>Location：指定创建虚拟环境的目录。</p><blockquote><p>一般创建虚拟环境都是一个项目可能创建一个虚拟环境，所以最好将环境创建在你运行的项目的根目录下。</p></blockquote><p><code>图2</code>中，我运行的项目是<code>F:\WorkPlace\pyhanlp</code>。所以目录选择在<code>F:\WorkPlace\pyhanlp\venv</code>。</p></li></ul><ul><li><p>Base interpreter：指定电脑上存在的Python编译器的目录。</p><blockquote><p>可以是你安装的Python，也可以是你使用anaconda创建的虚拟Pyhon。</p></blockquote><p>未完待续（缺少使用conda创建虚拟环境的内容）…</p></li><li><p>□ Inherit(继承) global site-packages：勾选该选项后则可以使用Base interpreter中配置的python环境所安装的所有组件；不选将和外界完全隔离,不加载Base interpreter中配置的python环境下的包，即完全是一个干净的环境，需要自己重装安装所需的包（重新安装所有包）。</p></li><li><p>□ Make available to all projects：表示可将此虚拟环境提供给所有项目使用。</p></li></ul><p>配置完成后，点击<code>OK</code>，会发现在<code>F:\WorkPlace\pyhanlp</code>目录下生成了一个<code>venv</code>文件夹。</p><h4 id="1-2-2-Existing-environment"><a href="#1-2-2-Existing-environment" class="headerlink" title="1.2.2 Existing environment"></a>1.2.2 Existing environment</h4><p><code>Existing environment</code>中只需要配置一项任务:<code>Interpreter</code>。这个就是指定你的电脑中已经存在的一项虚拟环境目录。</p><p>已经存在的虚拟环境目录可以是：</p><ol><li>自己通过控制台建立的一个新的虚拟环境目录。</li><li>自己以前通过<code>New environment</code>创建的虚拟环境的目录。</li></ol><h2 id="2-Conda-Environment"><a href="#2-Conda-Environment" class="headerlink" title="2 Conda Environment"></a>2 Conda Environment</h2><h3 id="2-1-Conda-Environment是什么？"><a href="#2-1-Conda-Environment是什么？" class="headerlink" title="2.1 Conda Environment是什么？"></a>2.1 Conda Environment是什么？</h3><p><code>Conda Environment</code>就是使用Anaconda中带有的Python解释器。</p><p>安装Anaconda软件，Anaconda会自带很多的包，其中包括Python解释器。因此如果电脑中安装了Anaconda软件，也可以使用Anaconda里面附带安装的Python解释器或者通过Anaconda创建的虚拟Python解释器。和上面的操作类似。</p><h3 id="2-2-如何配置-Conda-Environment？"><a href="#2-2-如何配置-Conda-Environment？" class="headerlink" title="2.2 如何配置 Conda Environment？"></a>2.2 如何配置 Conda Environment？</h3><p>打开Pycharm的Conda Environment配置界面，发现存在两种配置方式：</p><p><img src="/2022/04/12/PyCharm%E4%B8%ADPython-Interprets%E7%9A%84%E9%85%8D%E7%BD%AE/Conda_Environment%E9%85%8D%E7%BD%AE%E7%95%8C%E9%9D%A2.png" alt="图3 Conda Environment配置界面"></p><p>【注】<code>图3</code>左下角提示<code>Conda executable path is empty</code>是因为我没安装Conda。</p><h4 id="2-2-1-New-environment"><a href="#2-2-1-New-environment" class="headerlink" title="2.2.1 New environment"></a>2.2.1 New environment</h4><p>使用Anaconda创建一个新的虚拟Python环境。Anaconda会帮我们下载所指定的Python版本。</p><p><img src="/2022/04/12/PyCharm%E4%B8%ADPython-Interprets%E7%9A%84%E9%85%8D%E7%BD%AE/new_environment%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%A4%BA%E6%84%8F%E5%9B%BE(conda).png" alt="图4 new environment方式配置示意图"></p><p>需要配置的项：</p><ul><li><p>Location：指定通过Anaconda创建虚拟环境的目录。</p><blockquote><p>Anaconda创建的虚拟环境一般在Anaconda安装目录下的envs目录下。</p></blockquote></li><li><p>Python version：安装python版本号。</p></li><li><p>Conda executable：安装的Anaconda执行器的文件路径。</p></li><li><p>□ Make available to all projects：勾选后，表示可将此虚拟环境提供给所有项目使用。</p></li></ul><h4 id="2-2-2-Existing-environment"><a href="#2-2-2-Existing-environment" class="headerlink" title="2.2.2 Existing environment"></a>2.2.2 Existing environment</h4><h2 id="3-System-Interpreter"><a href="#3-System-Interpreter" class="headerlink" title="3 System Interpreter"></a>3 System Interpreter</h2><h3 id="3-1-如何配置系统Python解释器？"><a href="#3-1-如何配置系统Python解释器？" class="headerlink" title="3.1 如何配置系统Python解释器？"></a>3.1 如何配置系统Python解释器？</h3><h2 id="4-Pipenv-Environment"><a href="#4-Pipenv-Environment" class="headerlink" title="4 Pipenv Environment"></a>4 Pipenv Environment</h2><h3 id="4-1-Pipenv是什么？"><a href="#4-1-Pipenv是什么？" class="headerlink" title="4.1 Pipenv是什么？"></a>4.1 Pipenv是什么？</h3><h3 id="4-2-如何配置-Pipenv-Environment？"><a href="#4-2-如何配置-Pipenv-Environment？" class="headerlink" title="4.2 如何配置 Pipenv Environment？"></a>4.2 如何配置 Pipenv Environment？</h3><h4 id="4-2-1-准备步骤"><a href="#4-2-1-准备步骤" class="headerlink" title="4.2.1 准备步骤"></a>4.2.1 准备步骤</h4><h4 id="4-2-2-为新的Python项目设置pipenv"><a href="#4-2-2-为新的Python项目设置pipenv" class="headerlink" title="4.2.2 为新的Python项目设置pipenv"></a>4.2.2 为新的Python项目设置pipenv</h4><h4 id="4-2-3-为现有的Python项目配置pipenv"><a href="#4-2-3-为现有的Python项目配置pipenv" class="headerlink" title="4.2.3 为现有的Python项目配置pipenv"></a>4.2.3 为现有的Python项目配置pipenv</h4>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>软件使用</tag>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔1</title>
    <link href="/2022/02/21/%E9%9A%8F%E7%AC%941/"/>
    <url>/2022/02/21/%E9%9A%8F%E7%AC%941/</url>
    
    <content type="html"><![CDATA[<h1 id="数理逻辑中符号-rightarrow-、-leftrightarrow-、-Rightarrow-、-Leftrightarrow"><a href="#数理逻辑中符号-rightarrow-、-leftrightarrow-、-Rightarrow-、-Leftrightarrow" class="headerlink" title="数理逻辑中符号$\rightarrow$、$\leftrightarrow$、$\Rightarrow$、$\Leftrightarrow$"></a>数理逻辑中符号$\rightarrow$、$\leftrightarrow$、$\Rightarrow$、$\Leftrightarrow$</h1><div class="note note-info">            <p>前两种是运算符号；后两种是关系符号，它们没有运算结果，只是表示两个命题公式之间的关系。</p>          </div><h2 id="联结词"><a href="#联结词" class="headerlink" title="联结词"></a>联结词</h2><p>联结词用于联结两个命题，共有<strong>五种</strong>联结词：否定联结词<strong>“$\neg$”</strong>、合取联结词<strong>“$\land$”</strong>、析取联结词<strong>“$\lor$”</strong>、蕴涵联结词<strong>“$\rightarrow$”</strong>、等价联结词<strong>“$\leftrightarrow$”</strong>。</p><h3 id="rightarrow"><a href="#rightarrow" class="headerlink" title="$\rightarrow$"></a>$\rightarrow$</h3><p>称为<strong>蕴涵联结词</strong>，$p \rightarrow q$ 是“如果p，则q”的符号化形式。$p \rightarrow q$ 的真值表为：</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">$p \rightarrow q$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><h3 id="leftrightarrow"><a href="#leftrightarrow" class="headerlink" title="$\leftrightarrow$"></a>$\leftrightarrow$</h3><p>称为<strong>等价联结词</strong>，$p \leftrightarrow q$ 是“p当且仅当q”的符号化形式。$p \leftrightarrow q$ 的真值表为：</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">$p \leftrightarrow q$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><h2 id="等值与推理"><a href="#等值与推理" class="headerlink" title="等值与推理"></a>等值与推理</h2><h3 id="Rightarrow"><a href="#Rightarrow" class="headerlink" title="$\Rightarrow$"></a>$\Rightarrow$</h3><p>称为<strong>推导符号</strong>，当$A \rightarrow B$ 为永真式（重言式）时，可以表示为$A \Rightarrow B$。</p><h3 id="Leftrightarrow"><a href="#Leftrightarrow" class="headerlink" title="$\Leftrightarrow$"></a>$\Leftrightarrow$</h3><p>称为<strong>等价符号</strong>，当$A \leftrightarrow B$ 为永真式（重言式）时，可以表示为$A \Leftrightarrow B$。　　</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webots自学之路（一）</title>
    <link href="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="webots自学之路（一）"><a href="#webots自学之路（一）" class="headerlink" title="webots自学之路（一）"></a>webots自学之路（一）</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>基于webots的用户指导（User Guide），记录webots仿真软件的学习。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/sence.png" alt="图1 Webots界面简介图"></p><p>当场景树、文本编辑器、控制台关闭后如何打开？点击Menu / Tools，如图所示，从中进行开关。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/Webots%E7%95%8C%E9%9D%A2%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="图2 Webots界面基本操作"></p><h2 id="1-My-First-Simulation-in-Webots"><a href="#1-My-First-Simulation-in-Webots" class="headerlink" title="1 My First Simulation in Webots"></a>1 My First Simulation in Webots</h2><blockquote><p>本节主要内容：</p><ul><li>如何创建一个新项目？</li><li>如何添加新结点（包括<strong>RectangleArean</strong>、<strong>e-puck Robot</strong>和<strong>WoodenBox</strong>(Solid)）？</li><li>如何调整Arean的地砖尺寸和墙高？</li><li>如何调整箱子的大小、位置？</li><li>如何创建控制器（<strong>Controller</strong>）？</li></ul></blockquote><h3 id="1-1-创建新项目"><a href="#1-1-创建新项目" class="headerlink" title="1.1 创建新项目"></a>1.1 创建新项目</h3><p>在菜单栏中，选择Wizards $\to$ New Project Directory，如下图所示。 </p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/create_new_project.png" alt="图3 创建新项目示意图"></p><h3 id="1-2-对物体施加一个力（Apply-a-Force）"><a href="#1-2-对物体施加一个力（Apply-a-Force）" class="headerlink" title="1.2 对物体施加一个力（Apply a Force）"></a>1.2 对物体施加一个力（Apply a Force）</h3><p>在模拟过程中，使用<strong>Alt键 + 鼠标左键 + 鼠标拖拽</strong>可以对物体（<strong>e-puck Robot</strong>）施加一个力，这会导致机器人被拖走；如果对箱子（<strong>WoodenBox(Solid)<strong>）进行该操作，箱子没有什么反应，原因是箱子默认是不考虑质量（</strong>mass</strong>）的。如果给箱子一个质量，箱子就可以进行拖拽了，假如给箱子的质量足够小，机器人也可以推动箱子。</p><h3 id="1-3-创建控制器（Controller）"><a href="#1-3-创建控制器（Controller）" class="headerlink" title="1.3 创建控制器（Controller）"></a>1.3 创建控制器（Controller）</h3><p>在菜单栏中，选择Wizards $\to$ New Robot Controller，如下图所示。 </p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/create_new_controller.png" alt="图4 创建控制器示意图"></p><p>创建完成后，要将新建的控制器与机器人连接起来。”<strong>epuck_go_forward</strong>“ 就是我们创建的控制器。下图展示了控制器连接完成的结果。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/associate_controller.png" alt="图5 控制器连接完成示意图"></p><h2 id="2-Modification-of-the-Environment"><a href="#2-Modification-of-the-Environment" class="headerlink" title="2 Modification of the Environment"></a>2 Modification of the Environment</h2><blockquote><p>本节主要内容：</p><ul><li>如何删除结点（<strong>RectangleArean</strong>）？</li><li>介绍了实体结点（<strong>The Solid Node</strong>），或称作刚体（<strong>Rigid Body</strong>）。</li><li>如何创建一个球</li><li>如何显示球与地面的接触线（<strong>The contact points</strong>）</li><li>如何通过调整球的几何结构（<strong>Geometries</strong>），让球更圆。</li><li>介绍了DEF-USE机制（<strong>DEF-USE Mechanism</strong>）</li></ul></blockquote><h3 id="2-1-实体结点（The-Solid-Node）"><a href="#2-1-实体结点（The-Solid-Node）" class="headerlink" title="2.1 实体结点（The Solid Node）"></a>2.1 实体结点（The Solid Node）</h3><h3 id="2-2-创建一个球"><a href="#2-2-创建一个球" class="headerlink" title="2.2 创建一个球"></a>2.2 创建一个球</h3><p>接下来，我们要建模一个刚体球。</p><blockquote><p>&lt;动手 #1&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 2 / Create a Ball / Hands-on #4。</sup><br>在场景树中，选择最后一个结点，点击<strong>Add</strong>按钮。在新出现的对话框中，选择<strong>Solid</strong>（<strong>Base nodes $\to$ Solid</strong>），点击<strong>Add</strong>创建一个Solid结点。在场景树中，展开新创建的Solid结点，选择<strong>children</strong>字段，点击<strong>Add</strong>按钮。在新出现的对话框中，选择<strong>Shape</strong>（<strong>Base nodes $\to$ Shape</strong>），点击<strong>Add</strong>创建一个Shape结点。此时Solid只是一个点。展开Shape结点，选择<strong>appearance</strong>字段，添加一个<strong>PBRAppearance</strong>（<strong>Base nodes$\to$ PBRAppearance</strong>）结点；展开Shape结点，选择<strong>geometry</strong>字段，添加一个<strong>Sphere</strong>结点。展开<strong>PBRAppearance</strong>结点，将<strong>metalness</strong>字段设置为0，再将<strong>roughness</strong>字段设置为1。在Solid结点中，选择<strong>boudingObject</strong>字段，添加一个<strong>Sphere</strong>结点，然后，选择<strong>physics</strong>字段，添加一个<strong>Physics</strong>结点。</p><p>【注】：各节点和各字段的详细信息可以在Webots参考手册（Webots Reference Manual）中查询，下面给出metalness字段和roughness字段的说明。</p><ul><li>metalness字段用于指明Solid表面的金属特性，取值范围为0~1，金属度为0表示完全绝缘材料，而金属度为1表示完全金属材料。在实际中，其值设置，一般非0即1，因为现实中没有部分金属材料。</li><li>roughness字段用于指明Solid表面的粗糙度，取值范围为0~1，粗糙度为0表示非常光滑，而粗糙度为1表示非常粗糙。</li></ul></blockquote><p>结果如下图所示：</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/ball_1.png" alt="图6 球创建完成示意图"></p><h4 id="2-2-1-显示球与地面的接触线"><a href="#2-2-1-显示球与地面的接触线" class="headerlink" title="2.2.1 显示球与地面的接触线"></a>2.2.1 显示球与地面的接触线</h4><p>打开Show Contact Points（Menu / View / Optional Rendering / Show Contact Points）。</p><h4 id="2-2-2-让球变得更圆"><a href="#2-2-2-让球变得更圆" class="headerlink" title="2.2.2 让球变得更圆"></a>2.2.2 让球变得更圆</h4><p>此时，有两个<strong>Sphere</strong>结点，一个用于几何表示（<strong>children</strong>字段），一个用于定义物理边界（<strong>boundingObject</strong>字段）。将这两个Sphere结点的<strong>radius</strong>字段设置为0.05、<strong>subdivision</strong>字段设置为2。</p><p>【注】：</p><ul><li>subdivision字段用于指明细分度，取值范围为1~5。</li></ul><h3 id="2-3-DEF-USE机制"><a href="#2-3-DEF-USE机制" class="headerlink" title="2.3 DEF-USE机制"></a>2.3 DEF-USE机制</h3><p>DEF-USE机制，类似于程序设计中经常把多次用到的功能写成一个子函数，方便多次调用。比如，2.2.2节中两个Sphere结点都是相同的信息，故可以用DEF-USE机制合并它们。</p><blockquote><p>&lt;动手 #2&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 2 / DEF-USE Mechanism / Hands-on #6。</sup><br>选择第一个Sphere结点（children字段中的），在字段编辑器中的DEF框里，敲入BALL_GEOMETRY。选择boundingObject字段（包含第二个Sphere结点），点击右键选中<strong>Delete</strong>，清空它的信息。选择boundingObject字段， 添加BALL_GEOMETRY结点（USE / BALL_GEOMETRY）。</p></blockquote><p>这样，可以在修改第一个Sphere结点的信息后，第二个Sphere结点的信息也自动同步更新。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/DEF-USE%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图7 DEF-USE机制示意图"></p><h3 id="2-4-建墙"><a href="#2-4-建墙" class="headerlink" title="2.4 建墙"></a>2.4 建墙</h3><blockquote><p>要求：</p><ul><li>建立四堵墙将Arean围起来；</li><li>尽可能使用DEF-USE机制；</li><li>墙是静态的。</li></ul></blockquote><p>接下来，我们开始建墙。</p><blockquote><p>&lt;动手 #3&gt;：</p><ol><li>选择场景树中最后一个结点，添加一个Solid结点。</li><li>展开新添加的Solid结点，选择children字段，添加一个Shape结点。</li><li>展开新添加的Shape结点，选择appearance字段，添加一个PBRAppearance结点；选择geometry字段，添加一个Box结点。</li><li>展开PBRAppearance结点，将metalness字段设置为0，再将roughness字段设置为1；展开Box结点，选择size字段，将x设置为1。</li><li>选择Shape结点（Solid / children / Shape），在字段编辑器中DEF栏键入WALL_GEOMETRY。</li><li>移动墙到合适位置。</li><li>选择刚建好的新墙，使用 Ctrl+C 和 Ctrl+V 拷贝第二堵墙。</li><li>选择第二堵墙，展开Solid / children字段，删除Shape结点，选择childre字段，添加USE / WALL_GEOMETRY (Shape) 结点。【注】：此时调整第一堵墙的长宽高等几何学特征，第二堵墙也会随之变化。</li><li>第三、四堵墙同理。</li></ol></blockquote><p>此时，进行模拟，会发现机器穿墙而过，这是由于没有设置boundingObejct和physics字段，即此时墙还没有物理特性。设置完成后（与&lt;动手 #1&gt;类似，这里不再赘述。），机器人不再被允许穿墙而过。如果希望机器人可以撞开墙逃出去，可以在physics中将质量mass设置为一个较小值，此时，机器人可以撞开墙逃逸。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%A2%99%E5%BB%BA%E7%AB%8B%E5%AE%8C%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图8 墙建立完成示意图"></p><h2 id="3-Appearance"><a href="#3-Appearance" class="headerlink" title="3 Appearance"></a>3 Appearance</h2><blockquote><p>本节主要内容：</p><ul><li>通过<strong>另存为</strong>创建新的模拟环境（appearance.wbt）。</li><li><strong>Lights Node</strong>（灯光结点）。</li><li>修改墙的的外表（将墙涂成蓝色）。</li><li>给球的表面添加纹理。</li></ul></blockquote><h3 id="3-1-创建新的模拟环境"><a href="#3-1-创建新的模拟环境" class="headerlink" title="3.1 创建新的模拟环境"></a>3.1 创建新的模拟环境</h3><blockquote><p>&lt;动手 #4&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 3 / New Simulation / Hands-on #1。</sup></p><ol><li>打开原来的模拟环境。</li><li>点击Menu / File / Save World As …，将模拟环境另存为appearance.wb。</li></ol></blockquote><h3 id="3-2-灯光"><a href="#3-2-灯光" class="headerlink" title="3.2 灯光"></a>3.2 灯光</h3><p>环境的光由<strong>Light</strong>结点和背景决定。<strong>Light</strong>结点有三种类型：</p><ol><li><strong>DirectionalLight</strong>（方向光）结点：用于模拟无限远的光，如：太阳光。</li><li><strong>PointLight</strong>（点光）结点：用于模拟从单个点发散出的光，如：灯泡。</li><li><strong>SpotLight</strong>（聚光）结点：用于模拟锥形光，如：手电筒。</li></ol><p>三种灯光结点的比较如图所示：</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E4%B8%89%E7%A7%8D%E7%81%AF%E5%85%89%E7%9A%84%E6%AF%94%E8%BE%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图9 三种灯光的比较示意图，依次为DirectionLight、PointLight、SpotLight"></p><p>灯光所需的性能开销是比较大的，并且会降低模拟的速度，尤其是当需要投射阴影时。降低灯光的个数会提高<strong>渲染</strong>（render）的速度。三种灯光结点的渲染效率为：DirectionalLight &gt; PointLight &gt; SpotLight。</p><p>本模拟环境中，灯光结点在场景树中是不可见的，这是因为DirectionLight被包含在<strong>TexturedBackgroundLight</strong>结点中。</p><h3 id="3-3-修改墙的外表"><a href="#3-3-修改墙的外表" class="headerlink" title="3.3 修改墙的外表"></a>3.3 修改墙的外表</h3><p>Shape结点中的<strong>Appearance</strong>结点和<strong>PBRAppearance</strong>结点用于控制物体的颜色和纹理。 使用PBRAppearance结点能更好的获得渲染结果。</p><blockquote><p>&lt;动手 #5&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 3 / Modify the Appearance of the Walls / Hands-on #2。</sup></p><ol><li>找到第一堵墙（DEF-USE机制的母本墙），展开PBRAppearance结点（Solid / children / Shape / PBRAppearance ）。【注】：前提是已添加了PBRAppearance结点，添加方法在&lt;动手 #1&gt;中，这里不再赘述。</li><li>选择baseColor字段，设置为蓝色。</li><li>选择metalness字段，设置为0。</li><li>选择roughness字段，设置为0.5。</li><li>由于DEF-USE机制，四面墙都会变为蓝色，如图所示。</li></ol></blockquote><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%A2%99%E6%B6%82%E4%B8%BA%E8%93%9D%E8%89%B2%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图10 墙涂为蓝色结果示意图"></p><h3 id="3-4-给球的表面添加纹理"><a href="#3-4-给球的表面添加纹理" class="headerlink" title="3.4 给球的表面添加纹理"></a>3.4 给球的表面添加纹理</h3><blockquote><p>&lt;动手 #6&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 3 / Add a Texture to the Ball / Hands-on #3。</sup></p><ol><li>选择球（Solid结点），展开PBRAppearance结点（Solid / children / Shape / PBRAppearance ）。【注】：前提是已添加了PBRAppearance结点，添加方法在&lt;动手 #1&gt;中，这里不再赘述。</li><li>选择baseColorMap字段，添加一个<strong>ImageTexture</strong>结点。</li><li>展开ImageTexture结点，选择url字段，点击添加按钮。</li><li>选择**” “**，在字段编辑器中点击Select…按钮，选择一张图片作为球的纹理。示例中的图片路径为”WEBOTS_HOME/projects/default/worlds/textures/red_brick_wall.jpg”。　　</li></ol></blockquote><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/Webots%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%B9%E7%90%86%E5%9B%BE%E7%89%87.png" alt="图11 Webots提供的纹理图片"></p><p>Webots通过<strong>UV mapping</strong>（UV映射）函数将二维图像表示映射到三维模型上。纹理添加完成的结果如图所示。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E7%90%83%E6%B7%BB%E5%8A%A0%E7%BA%B9%E7%90%86%E5%AE%8C%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图12 球添加纹理完成示意图"></p><h3 id="3-5-不同的渲染模式"><a href="#3-5-不同的渲染模式" class="headerlink" title="3.5 不同的渲染模式"></a>3.5 不同的渲染模式</h3><p>两种渲染模式：</p><ul><li>线框渲染：打开方式为点击Menu / View / Wireframe Rendering。渲染结过如图所示。</li><li>普通渲染：打开方式为点击Menu / View / Plain Rendering。</li></ul><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E6%A1%86%E6%B8%B2%E6%9F%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图13 线框渲染示意图"></p><p>常用的其他渲染选项：</p><ul><li>显示坐标系：打开方式为点击Menu / View / Optional Rendering / Show Coordinates System。</li><li>显示距离传感器：打开方式为点击Menu / View / Optional Rendering / Show DistanceSensor Rays。</li></ul><h2 id="4-More-about-of-Controllers"><a href="#4-More-about-of-Controllers" class="headerlink" title="4 More about of Controllers"></a>4 More about of Controllers</h2><blockquote><p>本节主要内容：</p><ol><li>回顾另存为新模拟环境和创建新控制器的方法。</li><li>介绍E-puck模型。</li><li>讲述控制器的程序。</li></ol></blockquote><h3 id="4-1-创建新的模拟环境以及控制器"><a href="#4-1-创建新的模拟环境以及控制器" class="headerlink" title="4.1 创建新的模拟环境以及控制器"></a>4.1 创建新的模拟环境以及控制器</h3><blockquote><p>&lt;动手 #7&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 4 / Hands-on #1。</sup></p><ol><li>将原来的环境另存为collision_avoidance.wbt。【注】：创建方法同3.1节，这里不再赘述。</li><li>新建一个控制器epuck_avoid_collision。【注】：创建方法同1.3节，这里不再赘述。</li></ol></blockquote><h3 id="4-2-E-puck模型介绍"><a href="#4-2-E-puck模型介绍" class="headerlink" title="4.2 E-puck模型介绍"></a>4.2 E-puck模型介绍</h3><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/E-puck%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图14 E-puck模型示意图。绿色箭头表示机器人的前部；红线代表红外距离传感器的方向，字符串为传感器名称"></p><h3 id="4-3-控制器代码"><a href="#4-3-控制器代码" class="headerlink" title="4.3 控制器代码"></a>4.3 控制器代码</h3><div class="note note-info">            <p>本节代码引自Webots / User Guide / Tutorial / Tutorials 4，引用其中的C语言程序，并对C程序进行分析。</p>          </div><blockquote><p>&lt;程序清单 #1&gt;：<sup>【注】：引自Webots / User Guide / Tutorial / Tutorials 4 / The Controller Code。</sup></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/robot.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/distance_sensor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/motor.h&gt;</span></span><br><br><span class="hljs-comment">// time in [ms] of a simulation step</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIME_STEP 64</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SPEED 6.28</span><br><br><span class="hljs-comment">// entry point of the controller</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// initialize the Webots API</span><br>  wb_robot_init();<br><br>  <span class="hljs-comment">// internal variables</span><br>  <span class="hljs-keyword">int</span> i;<br>  WbDeviceTag ps[<span class="hljs-number">8</span>];<br>  <span class="hljs-keyword">char</span> ps_names[<span class="hljs-number">8</span>][<span class="hljs-number">4</span>] = &#123;<br>    <span class="hljs-string">&quot;ps0&quot;</span>, <span class="hljs-string">&quot;ps1&quot;</span>, <span class="hljs-string">&quot;ps2&quot;</span>, <span class="hljs-string">&quot;ps3&quot;</span>,<br>    <span class="hljs-string">&quot;ps4&quot;</span>, <span class="hljs-string">&quot;ps5&quot;</span>, <span class="hljs-string">&quot;ps6&quot;</span>, <span class="hljs-string">&quot;ps7&quot;</span><br>  &#125;;<br><br>  <span class="hljs-comment">// initialize devices</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> ; i++) &#123;<br>    ps[i] = wb_robot_get_device(ps_names[i]);<br>    wb_distance_sensor_enable(ps[i], TIME_STEP);<br>  &#125;<br><br>  WbDeviceTag left_motor = wb_robot_get_device(<span class="hljs-string">&quot;left wheel motor&quot;</span>);<br>  WbDeviceTag right_motor = wb_robot_get_device(<span class="hljs-string">&quot;right wheel motor&quot;</span>);<br>  wb_motor_set_position(left_motor, INFINITY);<br>  wb_motor_set_position(right_motor, INFINITY);<br>  wb_motor_set_velocity(left_motor, <span class="hljs-number">0.0</span>);<br>  wb_motor_set_velocity(right_motor, <span class="hljs-number">0.0</span>);<br><br>  <span class="hljs-comment">// feedback loop: step simulation until an exit event is received</span><br>  <span class="hljs-keyword">while</span> (wb_robot_step(TIME_STEP) != <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// read sensors outputs</span><br>    <span class="hljs-keyword">double</span> ps_values[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> ; i++)<br>      ps_values[i] = wb_distance_sensor_get_value(ps[i]);<br><br>    <span class="hljs-comment">// detect obstacles</span><br>    <span class="hljs-keyword">bool</span> right_obstacle =<br>      ps_values[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">80.0</span>;<br>    <span class="hljs-keyword">bool</span> left_obstacle =<br>      ps_values[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">6</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">7</span>] &gt; <span class="hljs-number">80.0</span>;<br><br>    <span class="hljs-comment">// initialize motor speeds at 50% of MAX_SPEED.</span><br>    <span class="hljs-keyword">double</span> left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>    <span class="hljs-keyword">double</span> right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br><br>    <span class="hljs-comment">// modify speeds according to obstacles</span><br>    <span class="hljs-keyword">if</span> (left_obstacle) &#123;<br>      <span class="hljs-comment">// turn right</span><br>      left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>      right_speed = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_obstacle) &#123;<br>      <span class="hljs-comment">// turn left</span><br>      left_speed  = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>      right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>    &#125;<br><br>    <span class="hljs-comment">// write actuators inputs</span><br>    wb_motor_set_velocity(left_motor, left_speed);<br>    wb_motor_set_velocity(right_motor, right_speed);<br>  &#125;<br><br>  <span class="hljs-comment">// cleanup the Webots API</span><br>  wb_robot_cleanup();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//EXIT_SUCCESS</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="4-4-代码结构分析"><a href="#4-4-代码结构分析" class="headerlink" title="4.4 代码结构分析"></a>4.4 代码结构分析</h3><h4 id="4-4-1-导入头文件"><a href="#4-4-1-导入头文件" class="headerlink" title="4.4.1 导入头文件"></a>4.4.1 导入头文件</h4><p>&lt;程序清单 #2&gt;：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/robot.h&gt;</span> <span class="hljs-comment">// 机器人结点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/distance_sensor.h&gt;</span> <span class="hljs-comment">// 距离传感器结点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/motor.h&gt;</span> <span class="hljs-comment">// 电机结点</span></span><br></code></pre></td></tr></table></figure><h4 id="4-4-2-添加宏"><a href="#4-4-2-添加宏" class="headerlink" title="4.4.2 添加宏"></a>4.4.2 添加宏</h4><p>&lt;程序清单 #3&gt;：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 定义每个模拟步骤的持续时间，用作wb_robot_step()函数的参数。</span><br><span class="hljs-comment">// 【注】：</span><br><span class="hljs-comment">// 1. 该持续时间的单位为毫秒；</span><br><span class="hljs-comment">// 2. 必须是WorldInfo节点中basicTimeStep字段中值的倍数。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIME_STEP 64</span><br></code></pre></td></tr></table></figure><h4 id="4-4-3-主函数结构"><a href="#4-4-3-主函数结构" class="headerlink" title="4.4.3 主函数结构"></a>4.4.3 主函数结构</h4><p>&lt;程序清单 #4&gt;：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// main函数为机器人控制器的入口；</span><br><span class="hljs-comment">// main函数的参数由机器人节点中controllerArgs字段给出。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;  <br>  <span class="hljs-comment">// 初始化 Webots API</span><br>  wb_robot_init();<br>  <br>  <span class="hljs-comment">// 初始化设备</span><br>  <span class="hljs-comment">// &lt;程序清单 #5&gt;</span><br>  <span class="hljs-comment">// &lt;程序清单 #6&gt;</span><br><br>  <span class="hljs-comment">// feedback loop: step simulation until an exit event is received</span><br>  <span class="hljs-keyword">while</span> (wb_robot_step(TIME_STEP) != <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// read sensors outputs</span><br>    <span class="hljs-comment">// &lt;程序清单 #7&gt;</span><br>    <span class="hljs-comment">// process behavior</span><br>    <span class="hljs-comment">// &lt;程序清单 #8&gt;</span><br>    <span class="hljs-comment">// &lt;程序清单 #9&gt;</span><br>    <span class="hljs-comment">// write actuators inputs</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 清理 Webots API</span><br>  wb_robot_cleanup();<br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 成功退出</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-4-初始化设备"><a href="#4-4-4-初始化设备" class="headerlink" title="4.4.4 初始化设备"></a>4.4.4 初始化设备</h4><ol><li><p>初始化距离传感器</p><p>&lt;程序清单 #5&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 初始化设备</span><br><span class="hljs-keyword">int</span> i;<br><br><span class="hljs-comment">// WbDeviceTag 相当于每个设备的标识符，它由 wb_robot_get_device 函数获取。</span><br><span class="hljs-comment">// 【作用】：</span><br><span class="hljs-comment">// 当一个函数需要调用该设备时，它将被作为该函数的第一个参数。</span><br><span class="hljs-comment">// 如本程序第18行所示。</span><br>WbDeviceTag ps[<span class="hljs-number">8</span>];<br><br><span class="hljs-comment">// E-puck八个距离传感器的名称</span><br><span class="hljs-keyword">char</span> ps_names[<span class="hljs-number">8</span>][<span class="hljs-number">4</span>] = &#123;<br>  <span class="hljs-string">&quot;ps0&quot;</span>, <span class="hljs-string">&quot;ps1&quot;</span>, <span class="hljs-string">&quot;ps2&quot;</span>, <span class="hljs-string">&quot;ps3&quot;</span>,<br>  <span class="hljs-string">&quot;ps4&quot;</span>, <span class="hljs-string">&quot;ps5&quot;</span>, <span class="hljs-string">&quot;ps6&quot;</span>, <span class="hljs-string">&quot;ps7&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>  ps[i] = wb_robot_get_device(ps_names[i]);<br>  wb_distance_sensor_enable(ps[i], TIME_STEP);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>初始化电机</p><p>&lt;程序清单 #6&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 获取左、右电机的设备标识符 WbDeviceTag。</span><br>WbDeviceTag left_motor = wb_robot_get_device(<span class="hljs-string">&quot;left wheel motor&quot;</span>);<br>WbDeviceTag right_motor = wb_robot_get_device(<span class="hljs-string">&quot;right wheel motor&quot;</span>);<br><br>wb_motor_set_position(left_motor, INFINITY);<br>wb_motor_set_position(right_motor, INFINITY);<br>wb_motor_set_velocity(left_motor, <span class="hljs-number">0.0</span>);<br>wb_motor_set_velocity(right_motor, <span class="hljs-number">0.0</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-4-5-循环避障"><a href="#4-4-5-循环避障" class="headerlink" title="4.4.5 循环避障"></a>4.4.5 循环避障</h4><ol><li><p>读取传感器数据<br> &lt;程序清单 #7&gt;：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 读传感器输出</span><br><span class="hljs-keyword">double</span> ps_values[<span class="hljs-number">8</span>];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> ; i++)<br>  ps_values[i] = wb_distance_sensor_get_value(ps[i]);<br></code></pre></td></tr></table></figure></li><li><p>碰撞检测</p><p>&lt;程序清单 #8&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// detect obstacles</span><br><span class="hljs-keyword">bool</span> right_obstacle =<br>  ps_values[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">80.0</span>;<br><span class="hljs-keyword">bool</span> left_obstacle =<br>  ps_values[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">6</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">7</span>] &gt; <span class="hljs-number">80.0</span>;<br></code></pre></td></tr></table></figure></li><li><p>驱动车轮避障</p><p>&lt;程序清单 #9&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SPEED 6.28</span><br>...<br><span class="hljs-comment">// initialize motor speeds at 50% of MAX_SPEED.</span><br><span class="hljs-keyword">double</span> left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br><span class="hljs-keyword">double</span> right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br><span class="hljs-comment">// modify speeds according to obstacles</span><br><span class="hljs-keyword">if</span> (left_obstacle) &#123;<br>  <span class="hljs-comment">// turn right</span><br>  left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>  right_speed = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_obstacle) &#123;<br>  <span class="hljs-comment">// turn left</span><br>  left_speed  = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>  right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>&#125;<br><span class="hljs-comment">// write actuators inputs</span><br>wb_motor_set_velocity(left_motor, left_speed);<br>wb_motor_set_velocity(right_motor, right_speed);<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-Conpound-Solid-and-Physics-Attributes"><a href="#5-Conpound-Solid-and-Physics-Attributes" class="headerlink" title="5 Conpound Solid and Physics Attributes"></a>5 Conpound Solid and Physics Attributes</h2><blockquote><p>本节主要内容：</p><ol><li>讲述了复合实体，并利复合实体构建一个哑铃（由两个球和一个圆柱体构成）。</li><li>讲述了Group结点、Transform结点。</li><li>讲述了一些简单的物理属性，比如：质量mass、密度density、质心centerOfMass。</li><li>讲述了rotation字段。</li></ol></blockquote><h3 id="5-1-复合实体（Conpound-Solid）"><a href="#5-1-复合实体（Conpound-Solid）" class="headerlink" title="5.1 复合实体（Conpound Solid）"></a>5.1 复合实体（Conpound Solid）</h3><p>在上面小节中我们所构造的实体，无论是球还是墙，都是只有<strong>一个</strong>几何体（或者是球体、或者是长方体），然而，现实中我们需要构造更复杂的实体（可能需要多个几何体来构成），比如：哑铃，它是由一个圆柱和两个球体构成的。这时，就需要引入<strong>复合实体Conpound Solid</strong>，利用<strong>Group</strong>结点来构建复杂模型，如图15所示，将三个几何体结点都放入Group结点的children字段里。</p><p>为了让哑铃片（Shape结点）可以相对哑铃（Solid结点）移动、旋转，故将哑铃片（Shape结点）放置在Transform结点中。哑铃杆（Shape结点）没有必要可以相对哑铃运动，故没有将哑铃杆（Shape结点）放置在Transform结点中。Transform结点的translation字段显示的不是绝对坐标系而是相对（相对于整个实体）坐标系。</p><blockquote><p>&lt;动手 #8&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 5 / Hands-on #1~2。</sup></p><ol><li>将原来的环境另存为compound_solid.wbt。【注】：创建方法同3.1节，这里不再赘述。</li><li>按照图15创建实体（哑铃）。</li><li>其中，圆柱（哑铃杆）的长为0.1， 半径为0.01；球体（哑铃片）半径为0.03， 细分度<strong>subdivision</strong>为2。<strong>注意</strong>：不要忘记（官方教程中没有提到）给这三个几何体的外表<strong>Shape/Appearance</strong>添加<strong>PBRAppearance</strong>结点，并将<strong>metalness</strong>字段设置为0、<strong>roughness</strong>字段设置为1，&lt;动手 #1&gt;中有详细的步骤，这里不再赘述。</li><li>最终结果如图16所示。</li></ol></blockquote><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%93%91%E9%93%83%E5%AE%9E%E4%BD%93%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="图15 哑铃实体的结构图。由多个几何体子结点所构成"></p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%93%91%E9%93%83%E6%9E%84%E9%80%A0%E5%AE%8C%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图16 哑铃构造完成示意图"></p><h3 id="5-2-物理属性"><a href="#5-2-物理属性" class="headerlink" title="5.2 物理属性"></a>5.2 物理属性</h3><p>本小节主要讲述了实体结点的一些简单的物理属性，这些物理属性都是在Physics结点（添加在Solid/physics字段）中调节的。</p><p>其中，主要是设置实体的质量，有两种方法：一是指定质量mass字段，二是指定密度density字段。当指定mass字段时，它定义固体的总质量（单位[kg]）；当指定density字段时，其值（单位[kg/m3]）乘以实体的体积，即为实体的总质量。1000[kg/m³]的密度对应于水的密度（默认值）。两种方法只能二选一（另一个字段在不使用时应当设置为-1）。</p><p>另外，关于质心，默认情况下，实体节点的质心设置在其原点（原点由实体的translation字段定义）。也可以通过Physics结点中的centerOfMass字段修改，其值是相对于原点指定的。</p><h3 id="5-3-旋转字段（The-Rotation-Field）"><a href="#5-3-旋转字段（The-Rotation-Field）" class="headerlink" title="5.3 旋转字段（The Rotation Field）"></a>5.3 旋转字段（The Rotation Field）</h3><p>rotation字段用于控制Transform结点的旋转。它有四个分量构成，前三个分量是定义旋转轴的单位向量，第四个分量定义了绕轴的旋转角度（单位为弧度<strong>rad</strong>，注意：1° = π/180 rad）。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/rotation%E5%AD%97%E6%AE%B5%E7%9A%84%E7%BB%84%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图17 rotation字段的组成示意图"></p><h3 id="5-4-边界对象"><a href="#5-4-边界对象" class="headerlink" title="5.4 边界对象"></a>5.4 边界对象</h3><p>本小节主要讲述了实体的边界几何形状，边界对象基本体种类如图18所示。边界对象的数量和基本体种类影响模拟的速度，模拟效率排序为：Sphere &gt; Box &gt; Capsule（胶囊） &gt; Cylinder（圆柱体） &gt;&gt; IndexedFaceSet，因此，尽量不要使用IndexedFaceSet。</p><p>对于地面来说，可以用Plane结点或者ElevationGrid结点构建。其中，Plane结点的模拟效率要高于ElevationGrid，但是Plane结点只能用来描述平面。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%87%A0%E4%BD%95%E7%BB%93%E7%82%B9%E7%A7%8D%E7%B1%BB%E5%9F%BA%E6%9C%AC%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图18 几何结点基本体种类示意图"></p><h2 id="6-4-Wheels-Robot"><a href="#6-4-Wheels-Robot" class="headerlink" title="6 4-Wheels Robot"></a>6 4-Wheels Robot</h2><h2 id="7-My-First-PROTO"><a href="#7-My-First-PROTO" class="headerlink" title="7 My First PROTO"></a>7 My First PROTO</h2><h2 id="8-Using-ROS"><a href="#8-Using-ROS" class="headerlink" title="8 Using ROS"></a>8 Using ROS</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Webots的用户指导.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Webots自学之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webots</tag>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第3章 渐近记法</title>
    <link href="/2021/05/01/%E6%B8%90%E8%BF%91%E8%AE%B0%E6%B3%95/"/>
    <url>/2021/05/01/%E6%B8%90%E8%BF%91%E8%AE%B0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-渐近记法"><a href="#第3章-渐近记法" class="headerlink" title="第3章 渐近记法"></a>第3章 渐近记法</h1><h2 id="1-渐近符"><a href="#1-渐近符" class="headerlink" title="1 渐近符"></a>1 渐近符</h2><p>在渐近符中“=”不代表相等，等号左右不能交换，即$A=B$，$B\ne A$。</p><h3 id="1-1-大O记法"><a href="#1-1-大O记法" class="headerlink" title="1.1 大O记法"></a>1.1 大O记法</h3><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f( n ) = O( g( n ) ), \tag{1}$$</p><p>即$\exists$ $c&gt;0,n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le f(n) \le c \cdot g(n)$。</p></li><li><p>举例：$2n^2=O(n^3)$，也有的文献中会表示为$2n^2 \in O(n^3)$，这两种表示方式是等价的，之所以可以这样表示，是因为（1）式的实质就是$f(n)$属于$g(n)$的函数集$O(g(n))$，即$O(g(n))=\lbrace f(n): there \ are \ consts \ c &gt; 0, n_0&gt;0 \ such \ that \ 0 \le f(n) \le c \cdot g(n) \rbrace$。这也进一步解释了“=”的意义。</p></li><li><p>用处：</p><ul><li>$f(n)=n^3 + O(n^2)$ 表示 $\exists h(n) \in O(n^2)$ 使得 $f(n) = n^3 + h(n)$。函数$f(n)$主要是$n^3$，但还是有一些低阶项。</li><li>$n^2+O(n)=O(n^2)$ 表示 $\forall f(n) \in O(n), \ \exists \ h(n) \in O(n^2) \ $使得 $n^2 + f(n)=h(n)$。这个例子更能体现“=”的意义。</li></ul></li></ol><h3 id="1-2-Omega-记法"><a href="#1-2-Omega-记法" class="headerlink" title="1.2 $\Omega$记法"></a>1.2 $\Omega$记法</h3><p>程序通常考虑的是运行时间的上界（$O$），有时也需要下界（$\Omega$）。</p><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f(n)=\Omega(g(n)), \tag{2}$$</p><p>即$\exists$ $c&gt;0,n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le c \cdot g(n) \le f(n)$。</p></li><li><p>举例：$\sqrt{n} = \Omega(lgn)$，同1.1节也可表示为$\sqrt{n} \in \Omega(lgn)$，也就是$f(n)$属于$g(n)$的函数集$\Omega(g(n))$，即$\Omega(g(n))=\lbrace f(n): there \ are \ consts \ c &gt; 0, n_0&gt;0 \ such \ that \ 0 \le c \cdot g(n) \le f(n) \rbrace$</p></li></ol><h3 id="1-3-Theta-记法"><a href="#1-3-Theta-记法" class="headerlink" title="1.3 $\Theta$记法"></a>1.3 $\Theta$记法</h3><ol><li>定义：$\Theta(g(n)) = O(g(n)) \cap \Omega(g(n)) \tag{3}$</li></ol><h3 id="1-4-小o记法"><a href="#1-4-小o记法" class="headerlink" title="1.4 小o记法"></a>1.4 小o记法</h3><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f( n ) = o( g( n ) ), \tag{4}$$</p><p>即 $\forall c&gt;0，\exists n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le f(n) \le c \cdot g(n)$。</p></li><li><p>举例：$2n^2=o(n^3)$</p></li></ol><h3 id="1-5-小-omega-记法"><a href="#1-5-小-omega-记法" class="headerlink" title="1.5 小$\omega$记法"></a>1.5 小$\omega$记法</h3><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f(n)=\omega(g(n)), \tag{5}$$</p><p>即$\forall c&gt;0，\exists n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le c \cdot g(n) \le f(n)$。</p></li></ol><h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h3><p><em>小$o$与大$O$、小$\omega$与$\Omega$的区别为前者是对于全部$c&gt;0$都成立，无论$c$多么小。</em></p><blockquote><p>上述符号与常用的等式符号的对应关系如下：<br>$O$：$\le$<br>$\Omega$：$\ge$<br>$\Theta$：$=$<br>$o$：$&lt;$<br>$\omega$：$&gt;$</p></blockquote><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p>《数据结构、算法与应用 C++描述》第2版</p></li><li><p>麻省理工学院公开课：<a href="https://www.bilibili.com/video/BV1Ex411T773?p=2">算法导论</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《数据结构、算法与应用 C++描述》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贝叶斯算法</title>
    <link href="/2021/04/12/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/12/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h1><div class="note note-info">            <p>本文是作者《机器学习》期末大作业的算法部分内容，主要摘抄自教材和课件，教材具体是哪一本已无法考究了。</p>          </div><h2 id="1-贝叶斯公式"><a href="#1-贝叶斯公式" class="headerlink" title="1 贝叶斯公式"></a>1 贝叶斯公式</h2><p>$$ P(A_i|B) = \frac {P(A_iB)} {P(B)} = \frac {P(A_i) P(B|A_i)} {\sum_{j=1}^nP(A_j)P(B|A_j)} , i = 1, 2, … \tag{1}$$</p><h2 id="2-概率的基本性质"><a href="#2-概率的基本性质" class="headerlink" title="2 概率的基本性质"></a>2 概率的基本性质</h2><ul><li>事件的概率在$0\sim1$之间，即$0≤P(A)≤1$</li><li>必然事件的概率为$1$</li><li>不可能事件的概率为$0$</li><li>当事件$A,B$互斥时，$P(A \cup B) = P(A) + P(B)$</li><li>当事件$A,B$为对立事件时，$P(A \cup B) = 1$</li><li>如果事件$A,B$相互独立，则$P(AB) = P(A)P(B)$</li></ul><h2 id="3-四种概率"><a href="#3-四种概率" class="headerlink" title="3 四种概率"></a>3 四种概率</h2><h3 id="（1）先验概率"><a href="#（1）先验概率" class="headerlink" title="（1）先验概率"></a>（1）先验概率</h3><p>　　是根据以往经验和分析得到的概率，即$P(A_i)$。</p><h3 id="（2）后验概率"><a href="#（2）后验概率" class="headerlink" title="（2）后验概率"></a>（2）后验概率</h3><p>　　事情已经发生，求这件事情发生是由某个因素引起的可能性的大小，即$P(A_i|B)$。</p><h3 id="（3）联合概率"><a href="#（3）联合概率" class="headerlink" title="（3）联合概率"></a>（3）联合概率</h3><p>　　表示两件事情共同发生的概率，即$P(A_iB)$，也可表示为$P(A_i \cap B)$。</p><h3 id="（4）条件概率"><a href="#（4）条件概率" class="headerlink" title="（4）条件概率"></a>（4）条件概率</h3><p>　　已知事件$A$发生条件相下事件$B$发生的概率，即$P(B|A)$。</p><h2 id="4-贝叶斯前期准备"><a href="#4-贝叶斯前期准备" class="headerlink" title="4 贝叶斯前期准备"></a>4 贝叶斯前期准备</h2><p>假设我们的输入空间为$X$，输入空间$X$中的每一条样本（特征向量）记为$x$，$x$有$n$个属性$x^{(1)}, x^{(2)}, x^{(3)}, … , x^{n-1}, x^n$。故记样本$x = {x^{(1)}, x^{(2)}, x^{(3)}, … , x^{n-1}, x^n}$。输出空间为$Y$，$Y$有$k$个类别标签，即$Y= {c_1, c_2, c_3, …, c_k}$。</p><p>将样本$x$分类为$c_i$所产生的期望损失，也称样本$x$上的“条件风险”为<br>$$\begin{matrix}<br>R\left( c_{i}\  \right|\ x) = \sum_{j = 1}^{k}{\lambda_{\text{ij}}P\left( c_{j}\  \right|\ x)}\ \ \tag{2} \<br>\end{matrix}$$</p><p>其中，$\lambda_{ij}$表示将标签为$c_j$的样本错误标记为$c_i$所产生的损失，$P(c_j|x)$表示样本$x$的标签为$c_j$的概率，也被称为后验概率。</p><p>我们的目的是找到一个假设$h(hypothesis)$，使得最小化总体损失</p><p>$$\begin{matrix}<br>R(h)\mathbb{= E}\left\lbrack R\left( h(x) \middle| x \right) \right\rbrack\ \ \tag{3} \<br>\end{matrix}$$</p><p>为了最小化总体损失，只需在每个样本上选择能使条件风险$R(c|x)$最小的类别标签即可，即</p><p>$$h^{*}(x)=\arg \min_{c \in Y}R(c\ \ |\ \  x) \tag{4}$$</p><p>在（2）式中，$\lambda_{ij}$可以记为</p><p>$$<br>\lambda_{ij} =<br>\begin{cases}<br>0, &amp; if\ {i = j}; \tag{5} \\<br>1, &amp; otherwise<br>\end{cases}<br>$$</p><p>将 (5) 式代入 (2) 式中，得$R\left( c_{i}\ \right|\ x) = 1 \times P\left( c_{1}\  \right|\ x) + 1 \times P\left( c_{2}\  \right|\ x) + ,\ldots, + 0 \times P\left( c_{i}\  \right|\ x) + ,\ldots, + 1 \times P\left( c_{n}\  \right|\ x)$，又因为事件$A\left( c_{i}\  \right|\ x),i = 1,2,3,\ldots,n$相互对立，根据1.1节性质(5) ，故条件风险$R\left( \text{c}\ \right|\ x)$可以表示为</p><p>$$\begin{matrix}<br>R\left( \text{c }\ \right|\ x) = 1 - P\left(\text{c }\ \right|\ x)\ \tag{6} \<br>\end{matrix}$$</p><p>将 (6) 式代入 (4) 式中$h^{*}(x) = \arg \min_{c \in Y}[1\  -\  P(c\ \ |\ \ x)]$，进一步转变为</p><p>$$h^{*}(x) = \arg \max_{c \in Y}P(c\ \ |\ \ x) \tag{7}$$</p><p>因此，预测样本$x$的类别标签的问题转变成求解后验概率$P\left( \text{c }\ \right|\ x)$的问题，即求出样本$x$关于输出空间$Y$中全部标签$c$的后验概率$P\left( \text{c }\ \right|\ x)$，然后进行比较，使得$P\left( \text{c }\ \right|\ x)$最大的$c$可以看做样本$x$的标签。下面从５节到７节，开始重点讨论后验概率$P\left( \text{c }\ \right|\ x)$的计算。</p><h2 id="5-朴素贝叶斯分类器"><a href="#5-朴素贝叶斯分类器" class="headerlink" title="5 朴素贝叶斯分类器"></a>5 朴素贝叶斯分类器</h2><p>由 (1) 式知，后验概率$P\left( \text{c }\ \right|\ x)$可以表示为</p><p>$$\begin{matrix}<br>P\left( \text{c }\ \right|\ x) = \frac{P(x,c)}{P(x)} = \frac{P(c)P\left( \text{x }\ \right|\ c)}{P(x)}\ \tag{8} \<br>\end{matrix}$$</p><p>其中$P(c)$称为先验概率，$P\left( \text{x }\ \right|\ c)$称为条件概率。因为样本$x$有$n$个属性，故在使用 (8) 式计算后验概率$P\left( \text{c }\ \right|\ x)$时，其中条件概率$P\left( \text{x }\ \right|\ c)$的计算是困难的。为了解决这个问题，科学家提出了朴素贝叶斯算法。</p><p>朴素贝叶斯假设所有属性相互独立，故根据1.1 节性质(6) ，(8) 式可以改写成</p><p>$$\begin{matrix}<br>P\left( \text{c }\ \right|\ x) = \frac{P(c)}{P(x)}\prod_{i = 1}^{n}{P\left( x^{(i)}\  \right|\ c)}\ \tag{9} \<br>\end{matrix}$$</p><p>其中$n$表示样本属性数量，$x^{(i)}$表示样本$x$在第$i$个属性上的取值。因为$P(x)$表示当前样本$x$的概率，因此，对于相同样本$x$，$P(x)$的取值是一样的。故将 (9) 式代入 (7) 式且忽略掉$P(x)$，得</p><p>$$h_{nb}(x)=\arg \max_{c \in Y} \prod_{i = 1}^nP(x_{(i)}\ |\ c) \tag{10}$$</p><p>(10) 式即为朴素贝叶斯分类器的表达式。</p><p>现在，开始讨论如何求解 (10) 式中的先验概率$P(c)$和条件概率$P\left( x^{(i)}\  \right|\ c)$。</p><p>假设有一训练集$D$，则$P(c)$可以用</p><p>$$\begin{matrix}<br>P(c) = \frac{\left| D_{c} \right|}{|D|}\ \tag{11} \<br>\end{matrix}$$</p><p>估计。其中，$D_{c}$表示训练集$D$中类别标签为$c$的样本集合，符号$||$表示集合中样本的数目。</p><p>条件概率$P\left( x^{(i)}\  \right|\ c)$可以用</p><p>$$\begin{matrix}<br>P\left( x^{(i)}\  \right|\ c) = \frac{\left| D_{c,x^{(i)}} \right|}{\left| D_{c} \right|}\ \tag{12}\<br>\end{matrix}$$</p><p>来估计。其中，$D_{c,x^{(i)}}$表示$D_{c}$中第$i$个样本属性为$x^{(i)}$的样本集合。显然，(12) 式只能计算离散属性的条件概率。当样本属性是连续型时，通常有两种方法来估计条件概率：</p><p>第一种方法是把每一个连续的数据离散化，然后用相应的离散区间替换连续数值。这种方法对于划分离散区间的粒度要求较高，不能太细，也不能太粗。</p><p>第二种方法是假设连续数据服从某个概率分布，使用训练数据估计分布参数，通常我们用高斯分布来表示连续数据的类条件概率分布。</p><p>通常在实验中使用第二种办法，即假定条件概率$P\left( x^{(i)}\  \right|\ c)$服从高斯正态分布，即</p><p>$$\begin{matrix}<br>P\left( x^{(i)}\  \right|\ c)\ \sim\ \mathcal{N}\left( \mu,\ \sigma^{2} \right)\ \tag{13} \<br>\end{matrix}$$</p><p>故条件概率$P\left( x^{(i)}\  \right|\ c)\ $可以用</p><p>$$\begin{matrix}<br>P\left( x^{(i)}\  \right|\ c) = \sqrt{\frac{1}{2\pi\sigma^{2}}}e^{\left( - \frac{1}{2\sigma^{2}}(x - \mu)^{2} \right)}\ \tag{14} \<br>\end{matrix}$$</p><p>来估计。其中，$\mu$和$\sigma^{2}$分别表示标签为$c$的样本在第$i$个属性上的均值和方差。</p><h2 id="6-拉普拉斯校准"><a href="#6-拉普拉斯校准" class="headerlink" title="6 拉普拉斯校准"></a>6 拉普拉斯校准</h2><p>在利用 (12) 式进行条件概率$P\left( x^{(i)}\  \right|\ c)$计算时，如果训练集$D$中没有标签为$c$且第$i$个属性为$x^{(i)}$的样本，即 (12) 式中等号右边分子$\left| D_{c,x^{(i)}} \right|$为零，则条件概率$P\left( x^{(i)}\  \right|\ c)$为零，又因为计算 (10) 式时，需要计算条件概率$P\left( x^{(i)}\  \right|\ c)$的累乘，故最终计算的概率值为零，显然，这是错误的。</p><p>那这个问题怎么解决呢？很简单，我们用一个简单的技巧就可以避免该问题，可以假定训练数据集$D$很大，以至于对于每个计数加一造成的估计概率的变化可以忽略不计，但这样可以避免样本数目为零。这种概率估计技术称为拉普拉斯校准或拉普拉斯估计法。其实它就是给某个属性不会出现的情况附一个$1$的常量值，其他情况也加上1，在把分母，即最后的总值加上个该属性的情况数。</p><p>因此，(11) (12 ) 式经拉普拉斯校准后，可以改写为</p><p>$$\begin{matrix}<br>\widehat{P}(c) = \frac{\left| D_{c} \right| + 1}{|D| + k}\ \tag{15} \<br>\end{matrix}$$</p><p>$$\begin{matrix}<br>\widehat{P}\left( x^{(i)}\  \right|\ c) = \frac{\left| D_{c,x^{(i)}} \right| + 1}{\left| D_{c} \right| + n_{i}}\ \tag{16} \<br>\end{matrix}$$</p><h2 id="7-简化计算"><a href="#7-简化计算" class="headerlink" title="7 简化计算"></a>7 简化计算</h2><p>由５节和６节可知先验概率$P(c)$和条件概率$P\left( x^{(i)}\  \right|\ c)$的计算公式，根据计算公式计算出先验概率$P(c)$和条件概率$P\left( x^{(i)}\  \right|\ c)$之后，代入 (10) 式即可求得所求。</p><p>但是，因为样本有多个属性且每个属性的取值情况是多样的，因此在计算 (10) 式时，累乘的代价无疑是恐怖的。但对于 (10) 式而言，我们最终比较的是概率的大小，并找到标签$c$使得当前样本$x$的后验概率$P\left( \text{c }\ \right|\ x)$最大。因此，我们无需花太多的时间计算概率的具体值。故对于 (10) 式取对数得</p><p>$$log[h_{nb}(x)] = \arg \max_{c \in Y}{logP(c) + \sum_{i=1}^n log[P(x^{(i)}\  |\  c)] } \tag{17}$$</p><p>而且 (17) 式还可以避免下溢出和浮点数取舍导致的问题（当概率足够小时，累乘积可能为零）。</p><p>至此，我们解决了朴素贝叶斯分类的全部问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树</title>
    <link href="/2021/04/12/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <url>/2021/04/12/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="1-为什么引入字典树？"><a href="#1-为什么引入字典树？" class="headerlink" title="1 为什么引入字典树？"></a>1 为什么引入字典树？</h2><p>在字符串匹配算法中，有一个瓶颈是如何判断集合（词典）中是否有该字符串。字典树能快速的进行匹配，且占用内存较少。</p><blockquote><p>字符串集合常用字典树存储</p></blockquote><h2 id="2-字典树是什么？"><a href="#2-字典树是什么？" class="headerlink" title="2 字典树是什么？"></a>2 字典树是什么？</h2><p>Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的<strong>多叉树</strong>结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。</p><p>以《自然语言处理入门》这本书中的例子和定义为例：字典树的每条边都对应一个字（当然也可以理解为：字典树除根结点之外的每个结点都存储一个字）。字典树的结点并不存储字符串（只存储字），当前结点对应的字符串即从根结点到该结点的路径，如：结点2对应的字符串为“入门”，但不是每个结点都对应一个字符串，图中只有蓝色结点（全部叶子结点和部分内部结点）有字符串与之对应。　</p><p><img src="/2021/04/12/%E5%AD%97%E5%85%B8%E6%A0%91/%E5%AD%97%E5%85%B8%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图1 字典树示意图。原图为《自然语言处理入门》图2-3"></p><p>字符串集合存储在字典树中，字典树中每一条路径（从根结点到特殊标记(蓝色)结点）就是一个字符串。要查询一个单词是否在这个字符串中，就要从根结点开始顺着这条路径往下走，如果能走到特殊标记结点，说明该单词在集合（词典）中，反之，不在。</p><h2 id="3-字典树的用处？"><a href="#3-字典树的用处？" class="headerlink" title="3 字典树的用处？"></a>3 字典树的用处？</h2><h2 id="4-字典树的实现"><a href="#4-字典树的实现" class="headerlink" title="4 字典树的实现"></a>4 字典树的实现</h2><p>&lt;程序清单 #1&gt;：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># Author：HuXiaoming</span><br><span class="hljs-comment"># Date: 2021-05-07</span><br><span class="hljs-comment"># 重现trie.py文件</span><br><span class="hljs-comment"># 参考 https://github.com/hankcs/pyhanlp/blob/master/tests/book/ch02/trie.py</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># 与 pyhanlp trie.py的不同之处：</span><br><span class="hljs-string"># 1. 用结点存储字，而不是边存储字</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        self._children = &#123;&#125;<br>        self._word = word<br>        self._isWords = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_child</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span>, overwirte: <span class="hljs-built_in">bool</span>=<span class="hljs-literal">False</span></span>):</span><br>        child = self._children.get(word)<br>        <span class="hljs-keyword">if</span> child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            child = Node(word)<br>            self._children[word] = child<br>        <span class="hljs-keyword">if</span> overwirte:<br>            self._isWords = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> child<br><br>    <span class="hljs-comment"># 删除孩子结点</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_del_child</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        child = self._children.get(word)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> child._children:<br>            <span class="hljs-comment"># 已没有孙子结点</span><br>            self._children.pop(word)<br>            <span class="hljs-keyword">del</span> child<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 有孙子结点</span><br>            <span class="hljs-comment"># 则儿子不再对应一个单词</span><br>            <span class="hljs-comment"># 但不删除儿子这个字</span><br>            child._isWords = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-keyword">if</span> words:<br>            word, words = words[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], words[<span class="hljs-number">1</span>:]<br>            child = self._children.get(word)<br>            child.delete(words)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 最后一个</span><br>            <span class="hljs-keyword">return</span><br>        self._del_child(word)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>(<span class="hljs-params">Node</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>().__init__(word=<span class="hljs-string">&quot;Root&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        state = self<br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(words) - <span class="hljs-number">1</span>:<br>                state = state._add_child(char, <span class="hljs-literal">False</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 词语words的最后一个字</span><br>                state = state._add_child(char, <span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-keyword">if</span> words <span class="hljs-keyword">in</span> self:<br>            word, words = words[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], words[<span class="hljs-number">1</span>:]<br>            child = self._children.get(word)<br>            child.delete(words)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;待删除词不在字典树中&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>):</span><br>        state = self<br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(words):<br>                state = state._children.get(char)<br>                <span class="hljs-keyword">if</span> state <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 词语words的最后一个字</span><br>        <span class="hljs-keyword">if</span> state._isWords:<br>            <span class="hljs-comment"># 搜索成功</span><br>            <span class="hljs-keyword">return</span> state<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># words的最后一个字在当前字典树中不是结束字</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span>(<span class="hljs-params">self, words</span>):</span><br>        <span class="hljs-keyword">return</span> self[words] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    trie = Trie()<br>    <span class="hljs-comment"># 增</span><br>    trie.append(<span class="hljs-string">&quot;机器&quot;</span>)<br>    trie.append(<span class="hljs-string">&quot;机器人&quot;</span>)<br>    trie.append(<span class="hljs-string">&quot;前进&quot;</span>)<br>    trie.append(<span class="hljs-string">&quot;机械臂&quot;</span>)<br><br>    <span class="hljs-comment"># 查</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;机器&quot;</span> <span class="hljs-keyword">in</span> trie<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;前面&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> trie<br><br>    <span class="hljs-comment"># 删</span><br>    trie.delete(<span class="hljs-string">&quot;机器&quot;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;机器&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> trie<br></code></pre></td></tr></table></figure><h2 id="5-字典树的改进"><a href="#5-字典树的改进" class="headerlink" title="5 字典树的改进"></a>5 字典树的改进</h2><h3 id="5-1-首字散列其余二分的字典树"><a href="#5-1-首字散列其余二分的字典树" class="headerlink" title="5.1 首字散列其余二分的字典树"></a>5.1 首字散列其余二分的字典树</h3><blockquote><p>这里是按照《自然语言处理入门》书中的说法。<br>但是，字典树是多叉树，不应该是二分查找。</p></blockquote><p>其实，就是用哈希表（散列表）存储第一个字，其余仍用树结构。</p><h3 id="5-2-双数组字典树"><a href="#5-2-双数组字典树" class="headerlink" title="5.2 双数组字典树"></a>5.2 双数组字典树</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>何晗. 自然语言处理入门[M]. 北京: 人民邮电出版社, 2019: 46-60.</li><li>邴越. 字典树的实现及应用[Z]. <a href="https://developer.aliyun.com/article/38231">https://developer.aliyun.com/article/38231</a>, 2016-5-5.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>以前在编写Python项目时，使用过threading包等多线程知识，但每次都是现查现用。在近期有关Webots的某个工程中，因Webots中Robot（Nao）控制问题（似乎与多线程有关，虽然作者不知道如何解释，但是将每个动作创建为线程就能很好的解决该问题），导致Nao无法执行本人的一串动作指令，如“走-&gt;左转-&gt;走”，机器人只能执行最后一个动作”走“，不是我们期盼的那样，先“走”，然后“左转”，然后再“走”；如果是动作指令”走-&gt;挥手“，机器人会边走边挥手（可能由于重心问题会倒），这似乎也确实证明了Webots中的动作是并行的。<br>本文将以上述工程的demo为例，讲述一下多线程的使用。</p><h2 id="1-概念先行"><a href="#1-概念先行" class="headerlink" title="1 概念先行"></a>1 概念先行</h2><h3 id="1-1-程序"><a href="#1-1-程序" class="headerlink" title="1.1 程序"></a>1.1 程序</h3><p>程序是一个指令序列，包括程序段（存储程序运行过程中的代码）和数据段（存储程序运行过程处理的数据）</p><h3 id="1-2-进程实体（进程映像）"><a href="#1-2-进程实体（进程映像）" class="headerlink" title="1.2 进程实体（进程映像）"></a>1.2 进程实体（进程映像）</h3><p>进程实体包括程序进程控制块（Process Control Block, PCB）、程序段、进程段。</p><h4 id="1-2-1-PCB"><a href="#1-2-1-PCB" class="headerlink" title="1.2.1 PCB"></a>1.2.1 PCB</h4><p>系统为运行的程序配置一个数据结构，叫做进程控制块。它用来存储进程的各种信息（如程序代码的存放位置）。<br>创建进程实质上式创建进程实体中的PCB；撤销进程实质上是撤销PCB。<strong>PCB是进程的存在的唯一标志！</strong></p><h3 id="1-3-进程："><a href="#1-3-进程：" class="headerlink" title="1.3 进程："></a>1.3 进程：</h3><p>下面三个定义取自王道考研《操作系统》，本人偏爱第三个，但它们都强调了进程的动态性（即进程是一个过程）。</p><ul><li>进程是程序的一次<strong>执行过程</strong>。</li><li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong>。</li><li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，它是系统进行资源分配和调度的一个独立单位。</li></ul><h4 id="1-3-1-为什么引入进程实体和进程？"><a href="#1-3-1-为什么引入进程实体和进程？" class="headerlink" title="1.3.1 为什么引入进程实体和进程？"></a>1.3.1 为什么引入进程实体和进程？</h4><p>在单道机处理系统中，计算机只能处理一道程序，该程序独占计算机（包含IO等其他资源）。而在引入多道程序技术后，计算机需要考虑如何分配资源，为了方便操作系统管理，因此引入了进程实体和进程两个概念。　</p><h4 id="1-3-2-进程与进程实体的区别"><a href="#1-3-2-进程与进程实体的区别" class="headerlink" title="1.3.2 进程与进程实体的区别"></a>1.3.2 进程与进程实体的区别</h4><ul><li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</li><li>进程和进程实体并不一样，进程是动态的，进程实体是静态的。</li><li>如果不要求严谨，也可以认为进程实体就是进程。</li></ul><h3 id="1-4-线程："><a href="#1-4-线程：" class="headerlink" title="1.4 线程："></a>1.4 线程：</h3><p>线程是轻量级进程。</p><h4 id="1-4-1-为什么引入线程？"><a href="#1-4-1-为什么引入线程？" class="headerlink" title="1.4.1 为什么引入线程？"></a>1.4.1 为什么引入线程？</h4><p>有的进程需要同时处理很多事情，而传统进程只能串行的执行一系列程序，为此，引入线程来提高<strong>并发度</strong>。<br>引入线程后，线程成为程序执行流的最小单位</p><h2 id="2-threading库"><a href="#2-threading库" class="headerlink" title="2 threading库"></a>2 threading库</h2><h3 id="2-1-利用Thread类创建线程"><a href="#2-1-利用Thread类创建线程" class="headerlink" title="2.1 利用Thread类创建线程"></a>2.1 利用Thread类创建线程</h3><p>&lt;代码示例1&gt;<a name="代码示例1"></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># author: HuXiaoming</span><br><span class="hljs-comment"># date: 2021-4-9</span><br><span class="hljs-comment"># using:</span><br><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startMove</span>(<span class="hljs-params">action: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行&quot;</span> + action + <span class="hljs-string">&quot;动作，进度为&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;%&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createThread</span>() -&gt; <span class="hljs-literal">None</span>:</span><br>    <span class="hljs-comment"># walk_ 用来与walk做区分</span><br>    actions = [<span class="hljs-string">&quot;walk&quot;</span>, <span class="hljs-string">&quot;turn left&quot;</span>, <span class="hljs-string">&quot;walk_&quot;</span>]<br><br>    <span class="hljs-comment"># 创建三个动作线程</span><br>    thread1 = Thread(target=startMove, args=(actions[<span class="hljs-number">0</span>], ))<br>    thread2 = Thread(target=startMove, args=(actions[<span class="hljs-number">1</span>], ))<br>    thread3 = Thread(target=startMove, args=(actions[<span class="hljs-number">2</span>], ))<br><br>    <span class="hljs-comment"># 调用start()函数，新的线程才创建成功，并开始执行入口函数 startMove 里面的代码。</span><br>    thread1.start()<br>    thread2.start()<br>    thread3.start()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    createThread()<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/result1.png"></p><p>分析：</p><p><strong>可见walk动作在执行到进度70%的时候被turn left动作抢占。</strong>如果想让执行顺序为”walk -&gt; turn left -&gt; walk_“，需要使用Lock进行互斥访问，见<a href="#2.3%E4%BA%92%E6%96%A5%E9%94%81">2.3</a>节。</p><h3 id="2-2-Thread类的封装"><a href="#2-2-Thread类的封装" class="headerlink" title="2.2 Thread类的封装"></a>2.2 Thread类的封装</h3><p>一开始我不理解既然有<a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B1">&lt;代码示例1&gt;</a>中18到20行所示的创建Thread对象的方法，为什么还要自己创建新的继承自Thread类的多线程类。这其实就是一种封装的思想，我们可以把一些功能写在这个新建的多线程类中（如：打印提示线程的创建）。<br>下面以my_thread.py为例进行介绍Thread类的封装。<br>&lt;代码示例2&gt;<a name="代码示例2"></a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># my_thread.py</span><br><span class="hljs-comment"># author: HuXiaoming</span><br><span class="hljs-comment"># date: 2021-4-9</span><br><span class="hljs-comment"># using:</span><br><br><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-keyword">from</span> demo.first_thread <span class="hljs-keyword">import</span> startMove<br><br>actions = [<span class="hljs-string">&quot;walk&quot;</span>, <span class="hljs-string">&quot;turn left&quot;</span>, <span class="hljs-string">&quot;walk_&quot;</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span>(<span class="hljs-params">Thread</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, action: <span class="hljs-built_in">str</span>, threadID: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.action = action<br>        self.threadID = threadID<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;动作线程创立，线程ID为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.action, self.threadID))<br><br>    <span class="hljs-comment"># start()就会调用run()函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======开始执行&#123;&#125;动作======&quot;</span>.<span class="hljs-built_in">format</span>(self.action))<br>        startMove(self.action)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======&#123;&#125;动作执行结束======&quot;</span>.<span class="hljs-built_in">format</span>(self.action))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions:<br>        myT = MyThread(action, i)<br>        myT.start()<br>        i += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/result2.png"></p><h3 id="2-3-互斥锁"><a href="#2-3-互斥锁" class="headerlink" title="2.3 互斥锁"></a>2.3 互斥锁<a name="2.3互斥锁"></a></h3><p>常用函数：</p><ol><li>Lock( ).acquire( )：请求；相当操作系统中的wait( )或者P操作。</li><li>Lock( ).release( )： 释放；相当操作系统中的signal( )或者V操作。</li><li>Lock( ).locked( )：判断是否被锁</li></ol><p>&lt;代码示例3&gt;：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># Author: HuXiaoming</span><br><span class="hljs-comment"># Date: 2021-4-21</span><br><span class="hljs-comment"># using: Lock锁</span><br><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock<br><br>mutex = Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startMove</span>(<span class="hljs-params">action: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>    mutex.acquire()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行&quot;</span> + action + <span class="hljs-string">&quot;动作，进度为&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;%&quot;</span>)<br>    mutex.release()<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createThread</span>() -&gt; <span class="hljs-literal">None</span>:</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程开始！&quot;</span>)<br><br>    <span class="hljs-comment"># walk_ 用来与walk做区分</span><br>    actions = [<span class="hljs-string">&quot;walk&quot;</span>, <span class="hljs-string">&quot;turn left&quot;</span>, <span class="hljs-string">&quot;walk_&quot;</span>]<br><br>    <span class="hljs-comment"># 创建三个动作线程</span><br>    thread1 = Thread(target=startMove, args=(actions[<span class="hljs-number">0</span>], ))<br>    thread2 = Thread(target=startMove, args=(actions[<span class="hljs-number">1</span>], ))<br>    thread3 = Thread(target=startMove, args=(actions[<span class="hljs-number">2</span>], ))<br><br>    thread_list = [thread1, thread2, thread3]<br><br>    <span class="hljs-comment"># 调用start()函数，新的线程才创建成功，并开始执行入口函数 startMove 里面的代码。</span><br>    thread1.start()<br>    thread2.start()<br>    thread3.start()<br><br>    <span class="hljs-comment"># 让主线程等待三个子程序结束后在结束</span><br>    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> thread_list:<br>        thread.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程结束！&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    createThread()<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/result3.png"></p><p>分析：</p><p>成功按顺序执行。在<a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B2">&lt;代码示例2&gt;</a>中可以将Lock对象封装在run函数里。</p><h2 id="3-queue库"><a href="#3-queue库" class="headerlink" title="3 queue库"></a>3 queue库</h2><h2 id="4-队列与线程的结合"><a href="#4-队列与线程的结合" class="headerlink" title="4 队列与线程的结合"></a>4 队列与线程的结合</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>王道考研《操作系统》</li><li>白月黑羽.python进阶.<a href="http://www.python3.vip/tut/py/extra/multi_thread/">多线程和多进程</a></li><li>Python官方文档.<a href="https://docs.python.org/zh-cn/3.7/library/threading.html?highlight=threading#threading.Thread.daemon">threading—基于线程的并发</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第17章 贪婪算法</title>
    <link href="/2021/04/06/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/06/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第17章-贪婪算法"><a href="#第17章-贪婪算法" class="headerlink" title="第17章 贪婪算法"></a>第17章 贪婪算法</h1><h2 id="1-概念先行"><a href="#1-概念先行" class="headerlink" title="1 概念先行"></a>1 概念先行</h2><ol><li>最优化问题：包含限制条件和优化函数</li><li><strong>可行解</strong>：符合限制条件的问题求解方案</li><li>最优解：使优化函数可能取得最佳值的可行解</li></ol><h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2 应用"></a>2 应用</h2><h3 id="2-1-渴婴问题-例17-1"><a href="#2-1-渴婴问题-例17-1" class="headerlink" title="2.1 渴婴问题[例17-1]"></a>2.1 渴婴问题[例17-1]</h3><h3 id="2-2-装载问题-例17-2"><a href="#2-2-装载问题-例17-2" class="headerlink" title="2.2 装载问题[例17-2]"></a>2.2 装载问题[例17-2]</h3><h3 id="2-3-最小成本通信网络-例17-3"><a href="#2-3-最小成本通信网络-例17-3" class="headerlink" title="2.3 最小成本通信网络[例17-3]"></a>2.3 最小成本通信网络[例17-3]</h3><h3 id="2-4-找零钱-例17-4"><a href="#2-4-找零钱-例17-4" class="headerlink" title="2.4 找零钱[例17-4]"></a>2.4 找零钱[例17-4]</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>小孩用1美元来买价值不足1美元的糖果，售货员希望用最少的硬币来找钱。硬币有25美分、10美分、5美分及1美分的硬币，而且数目不限。售货员每次选择一枚硬币，凑成要找的零钱。选择时采用贪心准则（<strong>本题是最能体现贪心思想的，为了给顾客数量最少的硬币，我们先选用大面值的硬币，然后次一点，然后再次一点的，直到完成找零任务</strong>）。直到凑成的零钱总数等于要找的零钱数。</p><h4 id="证明-练习17-1-："><a href="#证明-练习17-1-：" class="headerlink" title="证明[练习17-1]："></a>证明[练习17-1]：</h4><p>售货员只要有足够的硬币，使用找零问题的贪心算法，总能凑出硬币最少的零钱。<br>证明（假设法）：</p><ul><li>采用贪心算法得到的方案为用$[n_1, n_2, n_3, n_4]$个[25美分, 10美分, 5美分, 1美分]来找零，假设该方案不是最优解；</li><li>用2个10美分和1个五美分来代替1个25美分，方案变为$[n_1-1, n_2+2, n_3+1, n_4]$；</li><li>显然新方案中的硬币数变多了（如果其他面值小于25美分的来代替一个25美分，硬币增加的数量会更多）；</li><li>所以原方案为最优解，假设不成立。</li></ul>]]></content>
    
    
    <categories>
      
      <category>《数据结构、算法与应用 C++描述》</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第1章 C++回顾</title>
    <link href="/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-C-回顾"><a href="#第1章-C-回顾" class="headerlink" title="第1章 C++回顾"></a>第1章 C++回顾</h1><h2 id="1-7-递归函数"><a href="#1-7-递归函数" class="headerlink" title="1.7 递归函数"></a>1.7 递归函数</h2><h3 id="练习-24"><a href="#练习-24" class="headerlink" title="练习 24"></a>练习 24</h3><div class="note note-info">            <p><strong>题目：</strong></p><p>编写一个递归模板函数，确定元素x是否属于数组a[0: n-1]。</p>          </div><p>&lt;代码清单 #1&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 24.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_for_x_in_array_a</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T a[], <span class="hljs-keyword">const</span> T x, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> middle = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>((start + end) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(a[middle] == x)<br>            <span class="hljs-keyword">return</span> middle;<br>        <span class="hljs-comment">// cout &lt;&lt; middle &lt;&lt; endl;</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">search_for_x_in_array_a</span>(a, x, start, middle<span class="hljs-number">-1</span>);<br>            <span class="hljs-comment">// cout &lt;&lt; endl &lt;&lt; middle &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>) <span class="hljs-comment">// 关键</span><br>                <span class="hljs-built_in">search_for_x_in_array_a</span>(a, x, middle+<span class="hljs-number">1</span>, end);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试24</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_search_x</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">45</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-keyword">int</span> a_x = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//int a_x = 10;</span><br><br>    <span class="hljs-keyword">char</span> b[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br>    <span class="hljs-keyword">char</span> b_x = <span class="hljs-string">&#x27;w&#x27;</span>;<br>    <span class="hljs-comment">//char b_x = &#x27;e&#x27;;</span><br>    cout &lt;&lt; a_x &lt;&lt; <span class="hljs-string">&quot;在数组a中的下标为：&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">search_for_x_in_array_a</span>(a, a_x, <span class="hljs-number">0</span>, <span class="hljs-number">6</span><span class="hljs-number">-1</span>);<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; b_x &lt;&lt; <span class="hljs-string">&quot;在数组b中的下标为：&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">search_for_x_in_array_a</span>(b, b_x, <span class="hljs-number">0</span>, <span class="hljs-number">6</span><span class="hljs-number">-1</span>);<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">test_search_x</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p><strong>方法：</strong></p><p>我编写的是一个查找无序数组的递归版查找法。不同于折半查找的是，在一般情况下，程序将middle的两边都搜索一下，除非在middle的前面就遇到了待查元素，如数组a所示。</p>          </div><p>search函数在数组a中查找x的步骤如下图所示：</p><p><img src="/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/%E9%80%92%E5%BD%92.jpg" alt="图1 本题递归树示意图"></p><div class="note note-danger">            <p><strong>问题：</strong></p><p>一开始没有第20行，导致查找结果一直为-1。</p>          </div><div class="note note-success">            <p><strong>原因：</strong></p><p>查找结束时，递归函数返回上一层，不会中断（跳出所有的递归层）。又因为没有20行的if语句判断，故当前层的递归函数向下继续运行。</p><p><strong>解决办法：</strong></p><p>在20行加上if判断</p>          </div><h3 id="练习-25"><a href="#练习-25" class="headerlink" title="练习 25"></a>练习 25</h3><div class="note note-info">            <p><strong>题目：</strong>[子集生成方法（Subset Generation）] </p><p>编写一个C++递归函数，输出n个元素的所有子集。例如，三元素集{a,b,c}的子集是{}（空集）,{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}。这些子集用0/1组成的代码序列来表示分别是000,100,010,001,110,101,011,111(0表示相应的元素不在子集中，1表示相应的元素在子集中)。因此你的程序输出长度为n的0/1序列即可。</p>          </div><p>&lt;代码清单 #2&gt;<a name="代码清单2"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span> <span class="hljs-comment">// pow(double base, double exp)</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 25. 子集生成方法</span><br><span class="hljs-keyword">int</span> sequence[<span class="hljs-number">10000</span>][<span class="hljs-number">10000</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subset_generation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<span class="hljs-comment">// 空集的子集只有空集</span><br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1</span>; i ++)<br>            sequence[i][<span class="hljs-number">1</span>] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> row_length = <span class="hljs-built_in">subset_generation</span>(n<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> cur_row_length = <span class="hljs-number">2</span> * row_length;<br>        <span class="hljs-comment">// 拷贝两遍 n-1 个元素的信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = row_length; row &lt; cur_row_length; row ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">1</span>; col &lt;= n<span class="hljs-number">-1</span>; col ++)<br>                    sequence[row][col] = sequence[row-row_length][col];<br>        <span class="hljs-comment">// 添加第 n 个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; cur_row_length; row ++)<br>            sequence[row][n] = row &lt; row_length? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> cur_row_length;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subset_generation_with_non_recursive_funcation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 转二进制</span><br>    <span class="hljs-keyword">int</span> subset[n] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// n 位二进制转其能表示的最大十进制</span><br>    <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i --)<br>        number += <span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>, i);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= number; i ++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> temp_n = n;<br>        <span class="hljs-keyword">int</span> temp_i = i;<br>        <span class="hljs-keyword">while</span>(temp_i &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            subset[temp_n<span class="hljs-number">-1</span>] = temp_i % <span class="hljs-number">2</span>;<br>            temp_i /= <span class="hljs-number">2</span>;<br>            temp_n --;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            cout &lt;&lt; subset[j];<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 测试25</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_subset_generation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// n must lower than seven</span><br>    <span class="hljs-comment">// int n = 10;</span><br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">time_t</span> start_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; start_time &lt;&lt; endl;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;all subsets are:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-built_in">subset_generation</span>(n);<br>    <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i ++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            cout &lt;&lt; sequence[i][j];<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">time_t</span> end_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; end_time - start_time &lt;&lt; endl;<br>    start_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;with non-recursive_way, all subsets are:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">subset_generation_with_non_recursive_funcation</span>(n);<br>    end_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; end_time - start_time &lt;&lt; endl;<br>    <span class="hljs-comment">// 经测试，递归快一点</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">test_subset_generation</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>递归法</li></ol><ul><li>当 n = 0 时，即该 n 元素集为空集， 空集的子集只有一个空集，故输出为 0。</li><li>当 n = 1 时，即 1 元素集，比如{ a }，它有两个子集{ }， { a }， 故输出为 0、1。</li><li>当 n = 2 时，即 2 元素集，比如{ a, b }，它有四个子集{ }， { a }，{ b }，{ a，b}，故输出为 00、10、 01、 11。</li><li>…………</li></ul><p>下面我们用图表来表示一下规律。</p><p><img src="/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/%E5%9B%BE%E8%A1%A81.png" alt="图表1 n=1"></p><blockquote><p>如何由图表 1 推到图表 2：<br>第1步：将图表 1 拷贝两遍，形成图表 2 的蓝色区域。<br>第2步：将第二个元素的两种取值（0,1）插入图表 2， 如图表 2 绿色区域所示。</p></blockquote><p><img src="/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/%E5%9B%BE%E8%A1%A82.png" alt="图表2 n=2"></p><blockquote><p>图表 2 推图表 3 的步骤与图表 1 推图表 2 的步骤相同。</p></blockquote><p><img src="/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/%E5%9B%BE%E8%A1%A83.png" alt="图表3 n=3"></p><p>上述的图表 1 到 图表 3 是即为程序中第7行的sequence数组，它采用二维表格存储结果。</p><ol start="2"><li>二进制法<br>见<a href="#%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%952">&lt;代码清单2&gt;</a>第37行函数<code>void subset_generation_with_non_recursive_funcation(const int n)</code></li></ol><h3 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h3><p>1.7节课后练习全部代码见<a href="https://github.com/Hu-Xiaoming/code/tree/main/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%20C%2B%2B%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8B/chapter_1/section_1.7">github地址</a></p>]]></content>
    
    
    <categories>
      
      <category>《数据结构、算法与应用 C++描述》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
