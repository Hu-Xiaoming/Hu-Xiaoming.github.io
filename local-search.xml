<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Webots自学之路（一）</title>
    <link href="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="webots自学之路（一）"><a href="#webots自学之路（一）" class="headerlink" title="webots自学之路（一）"></a>webots自学之路（一）</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>　　基于webots的用户指导（User Guide），记录webots仿真软件的学习。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/sence.png" alt="图1 Webots界面简介图"></p><p>　　当场景树、文本编辑器、控制台关闭后如何打开？点击Menu / Tools，如图所示，从中进行开关。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/Webots%E7%95%8C%E9%9D%A2%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.png" alt="图2 Webots界面基本操作"></p><h2 id="1-My-First-Simulation-in-Webots"><a href="#1-My-First-Simulation-in-Webots" class="headerlink" title="1 My First Simulation in Webots"></a>1 My First Simulation in Webots</h2><blockquote><p>本节主要内容：</p><ul><li>如何创建一个新项目？</li><li>如何添加新结点（包括<strong>RectangleArean</strong>、<strong>e-puck Robot</strong>和<strong>WoodenBox</strong>(Solid)）？</li><li>如何调整Arean的地砖尺寸和墙高？</li><li>如何调整箱子的大小、位置？</li><li>如何创建控制器（<strong>Controller</strong>）？</li></ul></blockquote><h3 id="1-1-创建新项目"><a href="#1-1-创建新项目" class="headerlink" title="1.1 创建新项目"></a>1.1 创建新项目</h3><p>　　在菜单栏中，选择Wizards $\to$ New Project Directory，如下图所示。 </p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/create_new_project.png" alt="图3 创建新项目示意图"></p><h3 id="1-2-对物体施加一个力（Apply-a-Force）"><a href="#1-2-对物体施加一个力（Apply-a-Force）" class="headerlink" title="1.2 对物体施加一个力（Apply a Force）"></a>1.2 对物体施加一个力（Apply a Force）</h3><p>　　在模拟过程中，使用<strong>Alt键 + 鼠标左键 + 鼠标拖拽</strong>可以对物体（<strong>e-puck Robot</strong>）施加一个力，这会导致机器人被拖走；如果对箱子（<strong>WoodenBox(Solid)<strong>）进行该操作，箱子没有什么反应，原因是箱子默认是不考虑质量（</strong>mass</strong>）的。如果给箱子一个质量，箱子就可以进行拖拽了，假如给箱子的质量足够小，机器人也可以推动箱子。</p><h3 id="1-3-创建控制器（Controller）"><a href="#1-3-创建控制器（Controller）" class="headerlink" title="1.3 创建控制器（Controller）"></a>1.3 创建控制器（Controller）</h3><p>　　在菜单栏中，选择Wizards $\to$ New Robot Controller，如下图所示。 </p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/create_new_controller.png" alt="图4 创建控制器示意图"></p><p>　　创建完成后，要将新建的控制器与机器人连接起来。”<strong>epuck_go_forward</strong>“ 就是我们创建的控制器。下图展示了控制器连接完成的结果。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/associate_controller.png" alt="图5 控制器连接完成示意图"></p><h2 id="2-Modification-of-the-Environment"><a href="#2-Modification-of-the-Environment" class="headerlink" title="2 Modification of the Environment"></a>2 Modification of the Environment</h2><blockquote><p>本节主要内容：</p><ul><li>如何删除结点（<strong>RectangleArean</strong>）？</li><li>介绍了实体结点（<strong>The Solid Node</strong>），或称作刚体（<strong>Rigid Body</strong>）。</li><li>如何创建一个球</li><li>如何显示球与地面的接触线（<strong>The contact points</strong>）</li><li>如何通过调整球的几何结构（<strong>Geometries</strong>），让球更圆。</li><li>介绍了DEF-USE机制（<strong>DEF-USE Mechanism</strong>）</li></ul></blockquote><h3 id="2-1-实体结点（The-Solid-Node）"><a href="#2-1-实体结点（The-Solid-Node）" class="headerlink" title="2.1 实体结点（The Solid Node）"></a>2.1 实体结点（The Solid Node）</h3><h3 id="2-2-创建一个球"><a href="#2-2-创建一个球" class="headerlink" title="2.2 创建一个球"></a>2.2 创建一个球</h3><p>　　接下来，我们要建模一个刚体球。</p><blockquote><p>&lt;动手 #1&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 2 / Create a Ball / Hands-on #4。</sup><br>　　在场景树中，选择最后一个结点，点击<strong>Add</strong>按钮。在新出现的对话框中，选择<strong>Solid</strong>（<strong>Base nodes $\to$ Solid</strong>），点击<strong>Add</strong>创建一个Solid结点。在场景树中，展开新创建的Solid结点，选择<strong>children</strong>字段，点击<strong>Add</strong>按钮。在新出现的对话框中，选择<strong>Shape</strong>（<strong>Base nodes $\to$ Shape</strong>），点击<strong>Add</strong>创建一个Shape结点。此时Solid只是一个点。展开Shape结点，选择<strong>appearance</strong>字段，添加一个<strong>PBRAppearance</strong>（<strong>Base nodes$\to$ PBRAppearance</strong>）结点；展开Shape结点，选择<strong>geometry</strong>字段，添加一个<strong>Sphere</strong>结点。展开<strong>PBRAppearance</strong>结点，将<strong>metalness</strong>字段设置为0，再将<strong>roughness</strong>字段设置为1。在Solid结点中，选择<strong>boudingObject</strong>字段，添加一个<strong>Sphere</strong>结点，然后，选择<strong>physics</strong>字段，添加一个<strong>Physics</strong>字段。</p><p>【注】：各节点和各字段的详细信息可以在Webots参考手册（Webots Reference Manual）中查询，下面给出metalness字段和roughness字段的说明。</p><ul><li>metalness字段用于指明Solid表面的金属特性，取值范围为0~1，金属度为0表示完全绝缘材料，而金属度为1表示完全金属材料。在实际中，其值设置，一般非0即1，因为现实中没有部分金属材料。</li><li>roughness字段用于指明Solid表面的粗糙度，取值范围为0~1，粗糙度为0表示非常光滑，而粗糙度为1表示非常粗糙。</li></ul></blockquote><p>　　结果如下图所示：</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/ball_1.png" alt="图6 球创建完成示意图"></p><h4 id="2-2-1-显示球与地面的接触线"><a href="#2-2-1-显示球与地面的接触线" class="headerlink" title="2.2.1 显示球与地面的接触线"></a>2.2.1 显示球与地面的接触线</h4><p>　　打开Show Contact Points（Menu / View / Optional Rendering / Show Contact Points）。</p><h4 id="2-2-2-让球变得更圆"><a href="#2-2-2-让球变得更圆" class="headerlink" title="2.2.2 让球变得更圆"></a>2.2.2 让球变得更圆</h4><p>　　此时，有两个<strong>Sphere</strong>结点，一个用于几何表示（<strong>children</strong>字段），一个用于定义物理边界（<strong>boundingObject</strong>字段）。将这两个Sphere结点的<strong>radius</strong>字段设置为0.05、<strong>subdivision</strong>字段设置为2。</p><p>【注】：</p><ul><li>subdivision字段用于指明细分度，取值范围为1~5。</li></ul><h3 id="2-3-DEF-USE机制"><a href="#2-3-DEF-USE机制" class="headerlink" title="2.3 DEF-USE机制"></a>2.3 DEF-USE机制</h3><p>　　DEF-USE机制，类似于程序设计中经常把多次用到的功能写成一个子函数，方便多次调用。比如，2.2.2节中两个Sphere结点都是相同的信息，故可以用DEF-USE机制合并它们。</p><blockquote><p>&lt;动手 #2&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 2 / DEF-USE Mechanism / Hands-on #6。</sup><br>　　选择第一个Sphere结点（children字段中的），在字段编辑器中的DEF框里，敲入BALL_GEOMETRY。选择boundingObject字段（包含第二个Sphere结点），点击右键选中<strong>Delete</strong>，清空它的信息。选择boundingObject字段， 添加BALL_GEOMETRY结点（USE / BALL_GEOMETRY）。</p></blockquote><p>　　这样，可以在修改第一个Sphere结点的信息后，第二个Sphere结点的信息也自动同步更新。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/DEF-USE%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图7 DEF-USE机制示意图"></p><h3 id="2-4-建墙"><a href="#2-4-建墙" class="headerlink" title="2.4 建墙"></a>2.4 建墙</h3><blockquote><p>要求：</p><ul><li>建立四堵墙将Arean围起来；</li><li>尽可能使用DEF-USE机制；</li><li>墙是静态的。</li></ul></blockquote><p>　　接下来，我们开始建墙。</p><blockquote><p>&lt;动手 #3&gt;：</p><ol><li>选择场景树中最后一个结点，添加一个Solid结点。</li><li>展开新添加的Solid结点，选择children字段，添加一个Shape结点。</li><li>展开新添加的Shape结点，选择appearance字段，添加一个PBRAppearance结点；选择geometry字段，添加一个Box结点。</li><li>展开PBRAppearance结点，将metalness字段设置为0，再将roughness字段设置为1；展开Box结点，选择size字段，将x设置为1。</li><li>选择Shape结点（Solid / children / Shape），在字段编辑器中DEF栏键入WALL_GEOMETRY。</li><li>移动墙到合适位置。</li><li>选择刚建好的新墙，使用 Ctrl+C 和 Ctrl+V 拷贝第二堵墙。</li><li>选择第二堵墙，展开Solid / children字段，删除Shape结点，选择childre字段，添加USE / WALL_GEOMETRY (Shape) 结点。【注】：此时调整第一堵墙的长宽高等几何学特征，第二堵墙也会随之变化。</li><li>第三、四堵墙同理。</li></ol></blockquote><p>　　此时，进行模拟，会发现机器穿墙而过，这是由于没有设置boundingObejct和physics字段，即此时墙还没有物理特性。设置完成后（与&lt;动手 #1&gt;类似，这里不再赘述。），机器人不再被允许穿墙而过。如果希望机器人可以撞开墙逃出去，可以在physics中将质量mass设置为一个较小值，此时，机器人可以撞开墙逃逸。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%A2%99%E5%BB%BA%E7%AB%8B%E5%AE%8C%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图8 墙建立完成示意图"></p><h2 id="3-Appearance"><a href="#3-Appearance" class="headerlink" title="3 Appearance"></a>3 Appearance</h2><blockquote><p>本节主要内容：</p><ul><li>通过<strong>另存为</strong>创建新的模拟环境（appearance.wbt）。</li><li><strong>Lights Node</strong>（灯光结点）。</li><li>修改墙的的外表（将墙涂成蓝色）。</li><li>给球的表面添加纹理。</li></ul></blockquote><h3 id="3-1-创建新的模拟环境"><a href="#3-1-创建新的模拟环境" class="headerlink" title="3.1 创建新的模拟环境"></a>3.1 创建新的模拟环境</h3><blockquote><p>&lt;动手 #4&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 3 / New Simulation / Hands-on #1。</sup></p><ol><li>打开原来的模拟环境。</li><li>点击Menu / File / Save World As …，将模拟环境另存为appearance.wb。</li></ol></blockquote><h3 id="3-2-灯光"><a href="#3-2-灯光" class="headerlink" title="3.2 灯光"></a>3.2 灯光</h3><p>　　环境的光由<strong>Light</strong>结点和背景决定。<strong>Light</strong>结点有三种类型：</p><ol><li><strong>DirectionalLight</strong>（方向光）结点：用于模拟无限远的光，如：太阳光。</li><li><strong>PointLight</strong>（点光）结点：用于模拟从单个点发散出的光，如：灯泡。</li><li><strong>SpotLight</strong>（聚光）结点：用于模拟锥形光，如：手电筒。</li></ol><p>三种灯光结点的比较如图所示：</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E4%B8%89%E7%A7%8D%E7%81%AF%E5%85%89%E7%9A%84%E6%AF%94%E8%BE%83%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图9 三种灯光的比较示意图，依次为DirectionLight、PointLight、SpotLight"></p><p>　　灯光所需的性能开销是比较大的，并且会降低模拟的速度，尤其是当需要投射阴影时。降低灯光的个数会提高<strong>渲染</strong>（render）的速度。三种灯光结点的渲染效率为：DirectionalLight &gt; PointLight &gt; SpotLight。</p><p>　　本模拟环境中，灯光结点在场景树中是不可见的，这是因为DirectionLight被包含在<strong>TexturedBackgroundLight</strong>结点中。</p><h3 id="3-3-修改墙的外表"><a href="#3-3-修改墙的外表" class="headerlink" title="3.3 修改墙的外表"></a>3.3 修改墙的外表</h3><p>　　Shape结点中的<strong>Appearance</strong>结点和<strong>PBRAppearance</strong>结点用于控制物体的颜色和纹理。 使用PBRAppearance结点能更好的获得渲染结果。</p><blockquote><p>&lt;动手 #5&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 3 / Modify the Appearance of the Walls / Hands-on #2。</sup></p><ol><li>找到第一堵墙（DEF-USE机制的母本墙），展开PBRAppearance结点（Solid / children / Shape / PBRAppearance ）。【注】：前提是已添加了PBRAppearance结点，添加方法在&lt;动手 #1&gt;中，这里不再赘述。</li><li>选择baseColor字段，设置为蓝色。</li><li>选择metalness字段，设置为0。</li><li>选择roughness字段，设置为0.5。</li><li>由于DEF-USE机制，四面墙都会变为蓝色，如图所示。</li></ol></blockquote><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E5%A2%99%E6%B6%82%E4%B8%BA%E8%93%9D%E8%89%B2%E7%BB%93%E6%9E%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图10 墙涂为蓝色结果示意图"></p><h3 id="3-4-给球的表面添加纹理"><a href="#3-4-给球的表面添加纹理" class="headerlink" title="3.4 给球的表面添加纹理"></a>3.4 给球的表面添加纹理</h3><blockquote><p>&lt;动手 #6&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 3 / Add a Texture to the Ball / Hands-on #3。</sup></p><ol><li>选择球（Solid结点），展开PBRAppearance结点（Solid / children / Shape / PBRAppearance ）。【注】：前提是已添加了PBRAppearance结点，添加方法在&lt;动手 #1&gt;中，这里不再赘述。</li><li>选择baseColorMap字段，添加一个<strong>ImageTexture</strong>结点。</li><li>展开ImageTexture结点，选择url字段，点击添加按钮。</li><li>选择**” “**，在字段编辑器中点击Select…按钮，选择一张图片作为球的纹理。示例中的图片路径为”WEBOTS_HOME/projects/default/worlds/textures/red_brick_wall.jpg”。　　</li></ol></blockquote><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/Webots%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%B9%E7%90%86%E5%9B%BE%E7%89%87.png" alt="图11 Webots提供的纹理图片"></p><p>　　Webots通过<strong>UV mapping</strong>（UV映射）函数将二维图像表示映射到三维模型上。纹理添加完成的结果如图所示。</p><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E7%90%83%E6%B7%BB%E5%8A%A0%E7%BA%B9%E7%90%86%E5%AE%8C%E6%88%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图12 球添加纹理完成示意图"></p><h3 id="3-5-不同的渲染模式"><a href="#3-5-不同的渲染模式" class="headerlink" title="3.5 不同的渲染模式"></a>3.5 不同的渲染模式</h3><p>　　两种渲染模式：</p><ul><li>线框渲染：打开方式为点击Menu / View / Wireframe Rendering。渲染结过如图所示。</li><li>普通渲染：打开方式为点击Menu / View / Plain Rendering。</li></ul><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/%E7%BA%BF%E6%A1%86%E6%B8%B2%E6%9F%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图13 线框渲染示意图"></p><p>　　常用的其他渲染选项：</p><ul><li>显示坐标系：打开方式为点击Menu / View / Optional Rendering / Show Coordinates System。</li><li>显示距离传感器：打开方式为点击Menu / View / Optional Rendering / Show DistanceSensor Rays。</li></ul><h2 id="4-More-about-of-Controllers"><a href="#4-More-about-of-Controllers" class="headerlink" title="4 More about of Controllers"></a>4 More about of Controllers</h2><blockquote><p>本节主要内容：</p><ol><li>回顾另存为新模拟环境和创建新控制器的方法。</li><li>介绍E-puck模型。</li><li>讲述控制器的程序。</li></ol></blockquote><h3 id="4-1-创建新的模拟环境以及控制器"><a href="#4-1-创建新的模拟环境以及控制器" class="headerlink" title="4.1 创建新的模拟环境以及控制器"></a>4.1 创建新的模拟环境以及控制器</h3><blockquote><p>&lt;动手 #7&gt;：<sup>【注】：翻译自Webots / User Guide / Tutorial / Tutorials 4 / Hands-on #1。</sup></p><ol><li>将原来的环境另存为collision_avoidance.wbt。【注】：创建方法同3.1节，这里不再赘述。</li><li>新建一个控制器epuck_avoid_collision。【注】：创建方法同1.3节，这里不再赘述。</li></ol></blockquote><h3 id="4-2-E-puck模型介绍"><a href="#4-2-E-puck模型介绍" class="headerlink" title="4.2 E-puck模型介绍"></a>4.2 E-puck模型介绍</h3><p><img src="/2022/01/05/Webots%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/E-puck%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图14 E-puck模型示意图。绿色箭头表示机器人的前部；红线代表红外距离传感器的方向，字符串为传感器名称"></p><h3 id="4-3-控制器代码"><a href="#4-3-控制器代码" class="headerlink" title="4.3 控制器代码"></a>4.3 控制器代码</h3><div class="note note-info">            <p>本节代码引自Webots / User Guide / Tutorial / Tutorials 4，引用其中的C语言程序，并对C程序进行分析。</p>          </div><blockquote><p>&lt;程序清单 #1&gt;：<sup>【注】：引自Webots / User Guide / Tutorial / Tutorials 4 / The Controller Code。</sup></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/robot.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/distance_sensor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/motor.h&gt;</span></span><br><br><span class="hljs-comment">// time in [ms] of a simulation step</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIME_STEP 64</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SPEED 6.28</span><br><br><span class="hljs-comment">// entry point of the controller</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// initialize the Webots API</span><br>  wb_robot_init();<br><br>  <span class="hljs-comment">// internal variables</span><br>  <span class="hljs-keyword">int</span> i;<br>  WbDeviceTag ps[<span class="hljs-number">8</span>];<br>  <span class="hljs-keyword">char</span> ps_names[<span class="hljs-number">8</span>][<span class="hljs-number">4</span>] = &#123;<br>    <span class="hljs-string">&quot;ps0&quot;</span>, <span class="hljs-string">&quot;ps1&quot;</span>, <span class="hljs-string">&quot;ps2&quot;</span>, <span class="hljs-string">&quot;ps3&quot;</span>,<br>    <span class="hljs-string">&quot;ps4&quot;</span>, <span class="hljs-string">&quot;ps5&quot;</span>, <span class="hljs-string">&quot;ps6&quot;</span>, <span class="hljs-string">&quot;ps7&quot;</span><br>  &#125;;<br><br>  <span class="hljs-comment">// initialize devices</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> ; i++) &#123;<br>    ps[i] = wb_robot_get_device(ps_names[i]);<br>    wb_distance_sensor_enable(ps[i], TIME_STEP);<br>  &#125;<br><br>  WbDeviceTag left_motor = wb_robot_get_device(<span class="hljs-string">&quot;left wheel motor&quot;</span>);<br>  WbDeviceTag right_motor = wb_robot_get_device(<span class="hljs-string">&quot;right wheel motor&quot;</span>);<br>  wb_motor_set_position(left_motor, INFINITY);<br>  wb_motor_set_position(right_motor, INFINITY);<br>  wb_motor_set_velocity(left_motor, <span class="hljs-number">0.0</span>);<br>  wb_motor_set_velocity(right_motor, <span class="hljs-number">0.0</span>);<br><br>  <span class="hljs-comment">// feedback loop: step simulation until an exit event is received</span><br>  <span class="hljs-keyword">while</span> (wb_robot_step(TIME_STEP) != <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// read sensors outputs</span><br>    <span class="hljs-keyword">double</span> ps_values[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> ; i++)<br>      ps_values[i] = wb_distance_sensor_get_value(ps[i]);<br><br>    <span class="hljs-comment">// detect obstacles</span><br>    <span class="hljs-keyword">bool</span> right_obstacle =<br>      ps_values[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">80.0</span>;<br>    <span class="hljs-keyword">bool</span> left_obstacle =<br>      ps_values[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">6</span>] &gt; <span class="hljs-number">80.0</span> ||<br>      ps_values[<span class="hljs-number">7</span>] &gt; <span class="hljs-number">80.0</span>;<br><br>    <span class="hljs-comment">// initialize motor speeds at 50% of MAX_SPEED.</span><br>    <span class="hljs-keyword">double</span> left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>    <span class="hljs-keyword">double</span> right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br><br>    <span class="hljs-comment">// modify speeds according to obstacles</span><br>    <span class="hljs-keyword">if</span> (left_obstacle) &#123;<br>      <span class="hljs-comment">// turn right</span><br>      left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>      right_speed = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_obstacle) &#123;<br>      <span class="hljs-comment">// turn left</span><br>      left_speed  = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>      right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>    &#125;<br><br>    <span class="hljs-comment">// write actuators inputs</span><br>    wb_motor_set_velocity(left_motor, left_speed);<br>    wb_motor_set_velocity(right_motor, right_speed);<br>  &#125;<br><br>  <span class="hljs-comment">// cleanup the Webots API</span><br>  wb_robot_cleanup();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//EXIT_SUCCESS</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="4-4-代码结构分析"><a href="#4-4-代码结构分析" class="headerlink" title="4.4 代码结构分析"></a>4.4 代码结构分析</h3><h4 id="4-4-1-导入头文件"><a href="#4-4-1-导入头文件" class="headerlink" title="4.4.1 导入头文件"></a>4.4.1 导入头文件</h4><p>&lt;程序清单 #2&gt;：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/robot.h&gt;</span> <span class="hljs-comment">// 机器人结点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/distance_sensor.h&gt;</span> <span class="hljs-comment">// 距离传感器结点</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;webots/motor.h&gt;</span> <span class="hljs-comment">// 电机结点</span></span><br></code></pre></td></tr></table></figure><h4 id="4-4-2-添加宏"><a href="#4-4-2-添加宏" class="headerlink" title="4.4.2 添加宏"></a>4.4.2 添加宏</h4><p>&lt;程序清单 #3&gt;：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 定义每个模拟步骤的持续时间，用作wb_robot_step()函数的参数。</span><br><span class="hljs-comment">// 【注】：</span><br><span class="hljs-comment">// 1. 该持续时间的单位为毫秒；</span><br><span class="hljs-comment">// 2. 必须是WorldInfo节点中basicTimeStep字段中值的倍数。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIME_STEP 64</span><br></code></pre></td></tr></table></figure><h4 id="4-4-3-主函数结构"><a href="#4-4-3-主函数结构" class="headerlink" title="4.4.3 主函数结构"></a>4.4.3 主函数结构</h4><p>&lt;程序清单 #4&gt;：</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// main函数为机器人控制器的入口；</span><br><span class="hljs-comment">// main函数的参数由机器人节点中controllerArgs字段给出。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;  <br>  <span class="hljs-comment">// 初始化 Webots API</span><br>  wb_robot_init();<br>  <br>  <span class="hljs-comment">// 初始化设备</span><br>  <span class="hljs-comment">// &lt;程序清单 #5&gt;</span><br>  <span class="hljs-comment">// &lt;程序清单 #6&gt;</span><br><br>  <span class="hljs-comment">// feedback loop: step simulation until an exit event is received</span><br>  <span class="hljs-keyword">while</span> (wb_robot_step(TIME_STEP) != <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// read sensors outputs</span><br>    <span class="hljs-comment">// &lt;程序清单 #7&gt;</span><br>    <span class="hljs-comment">// process behavior</span><br>    <span class="hljs-comment">// &lt;程序清单 #8&gt;</span><br>    <span class="hljs-comment">// &lt;程序清单 #9&gt;</span><br>    <span class="hljs-comment">// write actuators inputs</span><br>  &#125;<br>  <br>  <span class="hljs-comment">// 清理 Webots API</span><br>  wb_robot_cleanup();<br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 成功退出</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-4-初始化设备"><a href="#4-4-4-初始化设备" class="headerlink" title="4.4.4 初始化设备"></a>4.4.4 初始化设备</h4><ol><li><p>初始化距离传感器</p><p>&lt;程序清单 #5&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 初始化设备</span><br><span class="hljs-keyword">int</span> i;<br><br><span class="hljs-comment">// WbDeviceTag 相当于每个设备的标识符，它由 wb_robot_get_device 函数获取。</span><br><span class="hljs-comment">// 【作用】：</span><br><span class="hljs-comment">// 当一个函数需要调用该设备时，它将被作为该函数的第一个参数。</span><br><span class="hljs-comment">// 如本程序第18行所示。</span><br>WbDeviceTag ps[<span class="hljs-number">8</span>];<br><br><span class="hljs-comment">// E-puck八个距离传感器的名称</span><br><span class="hljs-keyword">char</span> ps_names[<span class="hljs-number">8</span>][<span class="hljs-number">4</span>] = &#123;<br>  <span class="hljs-string">&quot;ps0&quot;</span>, <span class="hljs-string">&quot;ps1&quot;</span>, <span class="hljs-string">&quot;ps2&quot;</span>, <span class="hljs-string">&quot;ps3&quot;</span>,<br>  <span class="hljs-string">&quot;ps4&quot;</span>, <span class="hljs-string">&quot;ps5&quot;</span>, <span class="hljs-string">&quot;ps6&quot;</span>, <span class="hljs-string">&quot;ps7&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>  ps[i] = wb_robot_get_device(ps_names[i]);<br>  wb_distance_sensor_enable(ps[i], TIME_STEP);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>初始化电机</p><p>&lt;程序清单 #6&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 获取左、右电机的设备标识符 WbDeviceTag。</span><br>WbDeviceTag left_motor = wb_robot_get_device(<span class="hljs-string">&quot;left wheel motor&quot;</span>);<br>WbDeviceTag right_motor = wb_robot_get_device(<span class="hljs-string">&quot;right wheel motor&quot;</span>);<br><br>wb_motor_set_position(left_motor, INFINITY);<br>wb_motor_set_position(right_motor, INFINITY);<br>wb_motor_set_velocity(left_motor, <span class="hljs-number">0.0</span>);<br>wb_motor_set_velocity(right_motor, <span class="hljs-number">0.0</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-4-5-循环避障"><a href="#4-4-5-循环避障" class="headerlink" title="4.4.5 循环避障"></a>4.4.5 循环避障</h4><ol><li><p>读取传感器数据<br> &lt;程序清单 #7&gt;：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 读传感器输出</span><br><span class="hljs-keyword">double</span> ps_values[<span class="hljs-number">8</span>];<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span> ; i++)<br>  ps_values[i] = wb_distance_sensor_get_value(ps[i]);<br></code></pre></td></tr></table></figure></li><li><p>碰撞检测</p><p>&lt;程序清单 #8&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// detect obstacles</span><br><span class="hljs-keyword">bool</span> right_obstacle =<br>  ps_values[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">80.0</span>;<br><span class="hljs-keyword">bool</span> left_obstacle =<br>  ps_values[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">6</span>] &gt; <span class="hljs-number">80.0</span> ||<br>  ps_values[<span class="hljs-number">7</span>] &gt; <span class="hljs-number">80.0</span>;<br></code></pre></td></tr></table></figure></li><li><p>驱动车轮避障</p><p>&lt;程序清单 #9&gt;：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SPEED 6.28</span><br>...<br><span class="hljs-comment">// initialize motor speeds at 50% of MAX_SPEED.</span><br><span class="hljs-keyword">double</span> left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br><span class="hljs-keyword">double</span> right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br><span class="hljs-comment">// modify speeds according to obstacles</span><br><span class="hljs-keyword">if</span> (left_obstacle) &#123;<br>  <span class="hljs-comment">// turn right</span><br>  left_speed  = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>  right_speed = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_obstacle) &#123;<br>  <span class="hljs-comment">// turn left</span><br>  left_speed  = <span class="hljs-number">-0.5</span> * MAX_SPEED;<br>  right_speed = <span class="hljs-number">0.5</span> * MAX_SPEED;<br>&#125;<br><span class="hljs-comment">// write actuators inputs</span><br>wb_motor_set_velocity(left_motor, left_speed);<br>wb_motor_set_velocity(right_motor, right_speed);<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-Conpound-Solid-and-Physics-Attributes"><a href="#5-Conpound-Solid-and-Physics-Attributes" class="headerlink" title="5 Conpound Solid and Physics Attributes"></a>5 Conpound Solid and Physics Attributes</h2><h2 id="6-4-Wheels-Robot"><a href="#6-4-Wheels-Robot" class="headerlink" title="6 4-Wheels Robot"></a>6 4-Wheels Robot</h2><h2 id="7-My-First-PROTO"><a href="#7-My-First-PROTO" class="headerlink" title="7 My First PROTO"></a>7 My First PROTO</h2><h2 id="8-Using-ROS"><a href="#8-Using-ROS" class="headerlink" title="8 Using ROS"></a>8 Using ROS</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Webots的用户指导.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Webots自学之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webots</tag>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第3章 渐近记法</title>
    <link href="/2021/05/01/%E6%B8%90%E8%BF%91%E8%AE%B0%E6%B3%95/"/>
    <url>/2021/05/01/%E6%B8%90%E8%BF%91%E8%AE%B0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第3章-渐近记法"><a href="#第3章-渐近记法" class="headerlink" title="第3章 渐近记法"></a>第3章 渐近记法</h1><h2 id="1-渐近符"><a href="#1-渐近符" class="headerlink" title="1 渐近符"></a>1 渐近符</h2><p>　　在渐近符中“=”不代表相等，等号左右不能交换，即$A=B$，$B\ne A$。</p><h3 id="1-1-大O记法"><a href="#1-1-大O记法" class="headerlink" title="1.1 大O记法"></a>1.1 大O记法</h3><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f( n ) = O( g( n ) ), \tag{1}$$</p><p>即$\exists$ $c&gt;0,n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le f(n) \le c \cdot g(n)$。</p></li><li><p>举例：$2n^2=O(n^3)$，也有的文献中会表示为$2n^2 \in O(n^3)$，这两种表示方式是等价的，之所以可以这样表示，是因为（1）式的实质就是$f(n)$属于$g(n)$的函数集$O(g(n))$，即$O(g(n))=\lbrace f(n): there \ are \ consts \ c &gt; 0, n_0&gt;0 \ such \ that \ 0 \le f(n) \le c \cdot g(n) \rbrace$。这也进一步解释了“=”的意义。</p></li><li><p>用处：</p><ul><li>$f(n)=n^3 + O(n^2)$ 表示 $\exists h(n) \in O(n^2)$ 使得 $f(n) = n^3 + h(n)$。函数$f(n)$主要是$n^3$，但还是有一些低阶项。</li><li>$n^2+O(n)=O(n^2)$ 表示 $\forall f(n) \in O(n), \ \exists \ h(n) \in O(n^2) \ $使得 $n^2 + f(n)=h(n)$。这个例子更能体现“=”的意义。</li></ul></li></ol><h3 id="1-2-Omega-记法"><a href="#1-2-Omega-记法" class="headerlink" title="1.2 $\Omega$记法"></a>1.2 $\Omega$记法</h3><p>　　程序通常考虑的是运行时间的上界（$O$），有时也需要下界（$\Omega$）。</p><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f(n)=\Omega(g(n)), \tag{2}$$</p><p>即$\exists$ $c&gt;0,n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le c \cdot g(n) \le f(n)$。</p></li><li><p>举例：$\sqrt{n} = \Omega(lgn)$，同1.1节也可表示为$\sqrt{n} \in \Omega(lgn)$，也就是$f(n)$属于$g(n)$的函数集$\Omega(g(n))$，即$\Omega(g(n))=\lbrace f(n): there \ are \ consts \ c &gt; 0, n_0&gt;0 \ such \ that \ 0 \le c \cdot g(n) \le f(n) \rbrace$</p></li></ol><h3 id="1-3-Theta-记法"><a href="#1-3-Theta-记法" class="headerlink" title="1.3 $\Theta$记法"></a>1.3 $\Theta$记法</h3><ol><li>定义：$\Theta(g(n)) = O(g(n)) \cap \Omega(g(n)) \tag{3}$</li></ol><h3 id="1-4-小o记法"><a href="#1-4-小o记法" class="headerlink" title="1.4 小o记法"></a>1.4 小o记法</h3><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f( n ) = o( g( n ) ), \tag{4}$$</p><p>即 $\forall c&gt;0，\exists n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le f(n) \le c \cdot g(n)$。</p></li><li><p>举例：$2n^2=o(n^3)$</p></li></ol><h3 id="1-5-小-omega-记法"><a href="#1-5-小-omega-记法" class="headerlink" title="1.5 小$\omega$记法"></a>1.5 小$\omega$记法</h3><ol><li><p>定义：函数$f(n)$满足式</p><p>$$f(n)=\omega(g(n)), \tag{5}$$</p><p>即$\forall c&gt;0，\exists n_0&gt;0$，$\forall$ $n \ge n_0$，使得$0 \le c \cdot g(n) \le f(n)$。</p></li></ol><h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6 小结"></a>1.6 小结</h3><p>　　<em>小$o$与大$O$、小$\omega$与$\Omega$的区别为前者是对于全部$c&gt;0$都成立，无论$c$多么小。</em></p><blockquote><p>上述符号与常用的等式符号的对应关系如下：<br>$O$：$\le$<br>$\Omega$：$\ge$<br>$\Theta$：$=$<br>$o$：$&lt;$<br>$\omega$：$&gt;$</p></blockquote><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p>《数据结构、算法与应用 C++描述》第2版</p></li><li><p>麻省理工学院公开课：<a href="https://www.bilibili.com/video/BV1Ex411T773?p=2">算法导论</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《数据结构、算法与应用 C++描述》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贝叶斯算法</title>
    <link href="/2021/04/12/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/12/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h1><div class="note note-info">            <p>本文是作者《机器学习》期末大作业的算法部分内容，主要摘抄自教材和课件，教材具体是哪一本已无法考究了。</p>          </div><h2 id="1-贝叶斯公式"><a href="#1-贝叶斯公式" class="headerlink" title="1 贝叶斯公式"></a>1 贝叶斯公式</h2><p>$$ P(A_i|B) = \frac {P(A_iB)} {P(B)} = \frac {P(A_i) P(B|A_i)} {\sum_{j=1}^nP(A_j)P(B|A_j)} , i = 1, 2, … \tag{1}$$</p><h2 id="2-概率的基本性质"><a href="#2-概率的基本性质" class="headerlink" title="2 概率的基本性质"></a>2 概率的基本性质</h2><ul><li>事件的概率在$0\sim1$之间，即$0≤P(A)≤1$</li><li>必然事件的概率为$1$</li><li>不可能事件的概率为$0$</li><li>当事件$A,B$互斥时，$P(A \cup B) = P(A) + P(B)$</li><li>当事件$A,B$为对立事件时，$P(A \cup B) = 1$</li><li>如果事件$A,B$相互独立，则$P(AB) = P(A)P(B)$</li></ul><h2 id="3-四种概率"><a href="#3-四种概率" class="headerlink" title="3 四种概率"></a>3 四种概率</h2><h3 id="（1）先验概率"><a href="#（1）先验概率" class="headerlink" title="（1）先验概率"></a>（1）先验概率</h3><p>　　是根据以往经验和分析得到的概率，即$P(A_i)$。</p><h3 id="（2）后验概率"><a href="#（2）后验概率" class="headerlink" title="（2）后验概率"></a>（2）后验概率</h3><p>　　事情已经发生，求这件事情发生是由某个因素引起的可能性的大小，即$P(A_i|B)$。</p><h3 id="（3）联合概率"><a href="#（3）联合概率" class="headerlink" title="（3）联合概率"></a>（3）联合概率</h3><p>　　表示两件事情共同发生的概率，即$P(A_iB)$，也可表示为$P(A_i \cap B)$。</p><h3 id="（4）条件概率"><a href="#（4）条件概率" class="headerlink" title="（4）条件概率"></a>（4）条件概率</h3><p>　　已知事件$A$发生条件相下事件$B$发生的概率，即$P(B|A)$。</p><h2 id="4-贝叶斯前期准备"><a href="#4-贝叶斯前期准备" class="headerlink" title="4 贝叶斯前期准备"></a>4 贝叶斯前期准备</h2><p>　　假设我们的输入空间为$X$，输入空间$X$中的每一条样本（特征向量）记为$x$，$x$有$n$个属性$x^{(1)}, x^{(2)}, x^{(3)}, … , x^{n-1}, x^n$。故记样本$x = {x^{(1)}, x^{(2)}, x^{(3)}, … , x^{n-1}, x^n}$。输出空间为$Y$，$Y$有$k$个类别标签，即$Y= {c_1, c_2, c_3, …, c_k}$。</p><p>　　将样本$x$分类为$c_i$所产生的期望损失，也称样本$x$上的“条件风险”为<br>$$\begin{matrix}<br>R\left( c_{i}\  \right|\ x) = \sum_{j = 1}^{k}{\lambda_{\text{ij}}P\left( c_{j}\  \right|\ x)}\ \ \tag{2} \<br>\end{matrix}$$</p><p>其中，$\lambda_{ij}$表示将标签为$c_j$的样本错误标记为$c_i$所产生的损失，$P(c_j|x)$表示样本$x$的标签为$c_j$的概率，也被称为后验概率。</p><p>　　我们的目的是找到一个假设$h(hypothesis)$，使得最小化总体损失</p><p>$$\begin{matrix}<br>R(h)\mathbb{= E}\left\lbrack R\left( h(x) \middle| x \right) \right\rbrack\ \ \tag{3} \<br>\end{matrix}$$</p><p>为了最小化总体损失，只需在每个样本上选择能使条件风险$R(c|x)$最小的类别标签即可，即</p><p>$$h^{*}(x)=\arg \min_{c \in Y}R(c\ \ |\ \  x) \tag{4}$$</p><p>在（2）式中，$\lambda_{ij}$可以记为</p><p>$$<br>\lambda_{ij} =<br>\begin{cases}<br>0, &amp; if\ {i = j}; \tag{5} \\<br>1, &amp; otherwise<br>\end{cases}<br>$$</p><p>将 (5) 式代入 (2) 式中，得$R\left( c_{i}\ \right|\ x) = 1 \times P\left( c_{1}\  \right|\ x) + 1 \times P\left( c_{2}\  \right|\ x) + ,\ldots, + 0 \times P\left( c_{i}\  \right|\ x) + ,\ldots, + 1 \times P\left( c_{n}\  \right|\ x)$，又因为事件$A\left( c_{i}\  \right|\ x),i = 1,2,3,\ldots,n$相互对立，根据1.1节性质(5) ，故条件风险$R\left( \text{c}\ \right|\ x)$可以表示为</p><p>$$\begin{matrix}<br>R\left( \text{c }\ \right|\ x) = 1 - P\left(\text{c }\ \right|\ x)\ \tag{6} \<br>\end{matrix}$$</p><p>将 (6) 式代入 (4) 式中$h^{*}(x) = \arg \min_{c \in Y}[1\  -\  P(c\ \ |\ \ x)]$，进一步转变为</p><p>$$h^{*}(x) = \arg \max_{c \in Y}P(c\ \ |\ \ x) \tag{7}$$</p><p>因此，预测样本$x$的类别标签的问题转变成求解后验概率$P\left( \text{c }\ \right|\ x)$的问题，即求出样本$x$关于输出空间$Y$中全部标签$c$的后验概率$P\left( \text{c }\ \right|\ x)$，然后进行比较，使得$P\left( \text{c }\ \right|\ x)$最大的$c$可以看做样本$x$的标签。下面从５节到７节，开始重点讨论后验概率$P\left( \text{c }\ \right|\ x)$的计算。</p><h2 id="5-朴素贝叶斯分类器"><a href="#5-朴素贝叶斯分类器" class="headerlink" title="5 朴素贝叶斯分类器"></a>5 朴素贝叶斯分类器</h2><p>　　由 (1) 式知，后验概率$P\left( \text{c }\ \right|\ x)$可以表示为</p><p>$$\begin{matrix}<br>P\left( \text{c }\ \right|\ x) = \frac{P(x,c)}{P(x)} = \frac{P(c)P\left( \text{x }\ \right|\ c)}{P(x)}\ \tag{8} \<br>\end{matrix}$$</p><p>其中$P(c)$称为先验概率，$P\left( \text{x }\ \right|\ c)$称为条件概率。因为样本$x$有$n$个属性，故在使用 (8) 式计算后验概率$P\left( \text{c }\ \right|\ x)$时，其中条件概率$P\left( \text{x }\ \right|\ c)$的计算是困难的。为了解决这个问题，科学家提出了朴素贝叶斯算法。</p><p>　　朴素贝叶斯假设所有属性相互独立，故根据1.1 节性质(6) ，(8) 式可以改写成</p><p>$$\begin{matrix}<br>P\left( \text{c }\ \right|\ x) = \frac{P(c)}{P(x)}\prod_{i = 1}^{n}{P\left( x^{(i)}\  \right|\ c)}\ \tag{9} \<br>\end{matrix}$$</p><p>其中$n$表示样本属性数量，$x^{(i)}$表示样本$x$在第$i$个属性上的取值。因为$P(x)$表示当前样本$x$的概率，因此，对于相同样本$x$，$P(x)$的取值是一样的。故将 (9) 式代入 (7) 式且忽略掉$P(x)$，得</p><p>$$h_{nb}(x)=\arg \max_{c \in Y} \prod_{i = 1}^nP(x_{(i)}\ |\ c) \tag{10}$$</p><p>(10) 式即为朴素贝叶斯分类器的表达式。</p><p>　　现在，开始讨论如何求解 (10) 式中的先验概率$P(c)$和条件概率$P\left( x^{(i)}\  \right|\ c)$。</p><p>　　假设有一训练集$D$，则$P(c)$可以用</p><p>$$\begin{matrix}<br>P(c) = \frac{\left| D_{c} \right|}{|D|}\ \tag{11} \<br>\end{matrix}$$</p><p>估计。其中，$D_{c}$表示训练集$D$中类别标签为$c$的样本集合，符号$||$表示集合中样本的数目。</p><p>　　条件概率$P\left( x^{(i)}\  \right|\ c)$可以用</p><p>$$\begin{matrix}<br>P\left( x^{(i)}\  \right|\ c) = \frac{\left| D_{c,x^{(i)}} \right|}{\left| D_{c} \right|}\ \tag{12}\<br>\end{matrix}$$</p><p>来估计。其中，$D_{c,x^{(i)}}$表示$D_{c}$中第$i$个样本属性为$x^{(i)}$的样本集合。显然，(12) 式只能计算离散属性的条件概率。当样本属性是连续型时，通常有两种方法来估计条件概率：</p><p>　　第一种方法是把每一个连续的数据离散化，然后用相应的离散区间替换连续数值。这种方法对于划分离散区间的粒度要求较高，不能太细，也不能太粗。</p><p>　　第二种方法是假设连续数据服从某个概率分布，使用训练数据估计分布参数，通常我们用高斯分布来表示连续数据的类条件概率分布。</p><p>　　通常在实验中使用第二种办法，即假定条件概率$P\left( x^{(i)}\  \right|\ c)$服从高斯正态分布，即</p><p>$$\begin{matrix}<br>P\left( x^{(i)}\  \right|\ c)\ \sim\ \mathcal{N}\left( \mu,\ \sigma^{2} \right)\ \tag{13} \<br>\end{matrix}$$</p><p>故条件概率$P\left( x^{(i)}\  \right|\ c)\ $可以用</p><p>$$\begin{matrix}<br>P\left( x^{(i)}\  \right|\ c) = \sqrt{\frac{1}{2\pi\sigma^{2}}}e^{\left( - \frac{1}{2\sigma^{2}}(x - \mu)^{2} \right)}\ \tag{14} \<br>\end{matrix}$$</p><p>来估计。其中，$\mu$和$\sigma^{2}$分别表示标签为$c$的样本在第$i$个属性上的均值和方差。</p><h2 id="6-拉普拉斯校准"><a href="#6-拉普拉斯校准" class="headerlink" title="6 拉普拉斯校准"></a>6 拉普拉斯校准</h2><p>　　在利用 (12) 式进行条件概率$P\left( x^{(i)}\  \right|\ c)$计算时，如果训练集$D$中没有标签为$c$且第$i$个属性为$x^{(i)}$的样本，即 (12) 式中等号右边分子$\left| D_{c,x^{(i)}} \right|$为零，则条件概率$P\left( x^{(i)}\  \right|\ c)$为零，又因为计算 (10) 式时，需要计算条件概率$P\left( x^{(i)}\  \right|\ c)$的累乘，故最终计算的概率值为零，显然，这是错误的。</p><p>　　那这个问题怎么解决呢？很简单，我们用一个简单的技巧就可以避免该问题，可以假定训练数据集$D$很大，以至于对于每个计数加一造成的估计概率的变化可以忽略不计，但这样可以避免样本数目为零。这种概率估计技术称为拉普拉斯校准或拉普拉斯估计法。其实它就是给某个属性不会出现的情况附一个$1$的常量值，其他情况也加上1，在把分母，即最后的总值加上个该属性的情况数。</p><p>　　因此，(11) (12 ) 式经拉普拉斯校准后，可以改写为</p><p>$$\begin{matrix}<br>\widehat{P}(c) = \frac{\left| D_{c} \right| + 1}{|D| + k}\ \tag{15} \<br>\end{matrix}$$</p><p>$$\begin{matrix}<br>\widehat{P}\left( x^{(i)}\  \right|\ c) = \frac{\left| D_{c,x^{(i)}} \right| + 1}{\left| D_{c} \right| + n_{i}}\ \tag{16} \<br>\end{matrix}$$</p><h2 id="7-简化计算"><a href="#7-简化计算" class="headerlink" title="7 简化计算"></a>7 简化计算</h2><p>　　由５节和６节可知先验概率$P(c)$和条件概率$P\left( x^{(i)}\  \right|\ c)$的计算公式，根据计算公式计算出先验概率$P(c)$和条件概率$P\left( x^{(i)}\  \right|\ c)$之后，代入 (10) 式即可求得所求。</p><p>　　但是，因为样本有多个属性且每个属性的取值情况是多样的，因此在计算 (10) 式时，累乘的代价无疑是恐怖的。但对于 (10) 式而言，我们最终比较的是概率的大小，并找到标签$c$使得当前样本$x$的后验概率$P\left( \text{c }\ \right|\ x)$最大。因此，我们无需花太多的时间计算概率的具体值。故对于 (10) 式取对数得</p><p>$$log[h_{nb}(x)] = \arg \max_{c \in Y}{logP(c) + \sum_{i=1}^n log[P(x^{(i)}\  |\  c)] } \tag{17}$$</p><p>而且 (17) 式还可以避免下溢出和浮点数取舍导致的问题（当概率足够小时，累乘积可能为零）。</p><p>　　至此，我们解决了朴素贝叶斯分类的全部问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树</title>
    <link href="/2021/04/12/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <url>/2021/04/12/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="1-为什么引入字典树？"><a href="#1-为什么引入字典树？" class="headerlink" title="1 为什么引入字典树？"></a>1 为什么引入字典树？</h2><p>　　在字符串匹配算法中，有一个瓶颈是如何判断集合（词典）中是否有该字符串。字典树能快速的进行匹配，且占用内存较少。</p><blockquote><p>字符串集合常用字典树存储</p></blockquote><h2 id="2-字典树是什么？"><a href="#2-字典树是什么？" class="headerlink" title="2 字典树是什么？"></a>2 字典树是什么？</h2><p>　　Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的<strong>多叉树</strong>结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。</p><p>　　以《自然语言处理入门》这本书中的例子和定义为例：字典树的每条边都对应一个字（当然也可以理解为：字典树除根结点之外的每个结点都存储一个字）。字典树的结点并不存储字符串（只存储字），当前结点对应的字符串即从根结点到该结点的路径，如：结点2对应的字符串为“入门”，但不是每个结点都对应一个字符串，图中只有蓝色结点（全部叶子结点和部分内部结点）有字符串与之对应。　</p><p><img src="/2021/04/12/%E5%AD%97%E5%85%B8%E6%A0%91/%E5%AD%97%E5%85%B8%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="图1 字典树示意图。原图为《自然语言处理入门》图2-3"></p><p>　　字符串集合存储在字典树中，字典树中每一条路径（从根结点到特殊标记(蓝色)结点）就是一个字符串。要查询一个单词是否在这个字符串中，就要从根结点开始顺着这条路径往下走，如果能走到特殊标记结点，说明该单词在集合（词典）中，反之，不在。</p><h2 id="3-字典树的用处？"><a href="#3-字典树的用处？" class="headerlink" title="3 字典树的用处？"></a>3 字典树的用处？</h2><h2 id="4-字典树的实现"><a href="#4-字典树的实现" class="headerlink" title="4 字典树的实现"></a>4 字典树的实现</h2><p>&lt;程序清单 #1&gt;：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># Author：HuXiaoming</span><br><span class="hljs-comment"># Date: 2021-05-07</span><br><span class="hljs-comment"># 重现trie.py文件</span><br><span class="hljs-comment"># 参考 https://github.com/hankcs/pyhanlp/blob/master/tests/book/ch02/trie.py</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># 与 pyhanlp trie.py的不同之处：</span><br><span class="hljs-string"># 1. 用结点存储字，而不是边存储字</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        self._children = &#123;&#125;<br>        self._word = word<br>        self._isWords = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_add_child</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span>, overwirte: <span class="hljs-built_in">bool</span>=<span class="hljs-literal">False</span></span>):</span><br>        child = self._children.get(word)<br>        <span class="hljs-keyword">if</span> child <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            child = Node(word)<br>            self._children[word] = child<br>        <span class="hljs-keyword">if</span> overwirte:<br>            self._isWords = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> child<br><br>    <span class="hljs-comment"># 删除孩子结点</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_del_child</span>(<span class="hljs-params">self, word: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        child = self._children.get(word)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> child._children:<br>            <span class="hljs-comment"># 已没有孙子结点</span><br>            self._children.pop(word)<br>            <span class="hljs-keyword">del</span> child<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 有孙子结点</span><br>            <span class="hljs-comment"># 则儿子不再对应一个单词</span><br>            <span class="hljs-comment"># 但不删除儿子这个字</span><br>            child._isWords = <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-keyword">if</span> words:<br>            word, words = words[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], words[<span class="hljs-number">1</span>:]<br>            child = self._children.get(word)<br>            child.delete(words)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 最后一个</span><br>            <span class="hljs-keyword">return</span><br>        self._del_child(word)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>(<span class="hljs-params">Node</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>().__init__(word=<span class="hljs-string">&quot;Root&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        state = self<br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(words) - <span class="hljs-number">1</span>:<br>                state = state._add_child(char, <span class="hljs-literal">False</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 词语words的最后一个字</span><br>                state = state._add_child(char, <span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-keyword">if</span> words <span class="hljs-keyword">in</span> self:<br>            word, words = words[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>], words[<span class="hljs-number">1</span>:]<br>            child = self._children.get(word)<br>            child.delete(words)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;待删除词不在字典树中&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, words: <span class="hljs-built_in">str</span></span>):</span><br>        state = self<br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words):<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(words):<br>                state = state._children.get(char)<br>                <span class="hljs-keyword">if</span> state <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 词语words的最后一个字</span><br>        <span class="hljs-keyword">if</span> state._isWords:<br>            <span class="hljs-comment"># 搜索成功</span><br>            <span class="hljs-keyword">return</span> state<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># words的最后一个字在当前字典树中不是结束字</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span>(<span class="hljs-params">self, words</span>):</span><br>        <span class="hljs-keyword">return</span> self[words] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    trie = Trie()<br>    <span class="hljs-comment"># 增</span><br>    trie.append(<span class="hljs-string">&quot;机器&quot;</span>)<br>    trie.append(<span class="hljs-string">&quot;机器人&quot;</span>)<br>    trie.append(<span class="hljs-string">&quot;前进&quot;</span>)<br>    trie.append(<span class="hljs-string">&quot;机械臂&quot;</span>)<br><br>    <span class="hljs-comment"># 查</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;机器&quot;</span> <span class="hljs-keyword">in</span> trie<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;前面&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> trie<br><br>    <span class="hljs-comment"># 删</span><br>    trie.delete(<span class="hljs-string">&quot;机器&quot;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;机器&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> trie<br></code></pre></td></tr></table></figure><h2 id="5-字典树的改进"><a href="#5-字典树的改进" class="headerlink" title="5 字典树的改进"></a>5 字典树的改进</h2><h3 id="5-1-首字散列其余二分的字典树"><a href="#5-1-首字散列其余二分的字典树" class="headerlink" title="5.1 首字散列其余二分的字典树"></a>5.1 首字散列其余二分的字典树</h3><blockquote><p>这里是按照《自然语言处理入门》书中的说法。<br>但是，字典树是多叉树，不应该是二分查找。</p></blockquote><p>　　其实，就是用哈希表（散列表）存储第一个字，其余仍用树结构。</p><h3 id="5-2-双数组字典树"><a href="#5-2-双数组字典树" class="headerlink" title="5.2 双数组字典树"></a>5.2 双数组字典树</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>何晗. 自然语言处理入门[M]. 北京: 人民邮电出版社, 2019: 46-60.</li><li>邴越. 字典树的实现及应用[Z]. <a href="https://developer.aliyun.com/article/38231">https://developer.aliyun.com/article/38231</a>, 2016-5-5.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>　　以前在编写Python项目时，使用过threading包等多线程知识，但每次都是现查现用。在近期有关Webots的某个工程中，因Webots中Robot（Nao）控制问题（似乎与多线程有关，虽然作者不知道如何解释，但是将每个动作创建为线程就能很好的解决该问题），导致Nao无法执行本人的一串动作指令，如“走-&gt;左转-&gt;走”，机器人只能执行最后一个动作”走“，不是我们期盼的那样，先“走”，然后“左转”，然后再“走”；如果是动作指令”走-&gt;挥手“，机器人会边走边挥手（可能由于重心问题会倒），这似乎也确实证明了Webots中的动作是并行的。<br>　　本文将以上述工程的demo为例，讲述一下多线程的使用。</p><h2 id="1-概念先行"><a href="#1-概念先行" class="headerlink" title="1 概念先行"></a>1 概念先行</h2><h3 id="1-1-程序"><a href="#1-1-程序" class="headerlink" title="1.1 程序"></a>1.1 程序</h3><p>　　程序是一个指令序列，包括程序段（存储程序运行过程中的代码）和数据段（存储程序运行过程处理的数据）</p><h3 id="1-2-进程实体（进程映像）"><a href="#1-2-进程实体（进程映像）" class="headerlink" title="1.2 进程实体（进程映像）"></a>1.2 进程实体（进程映像）</h3><p>　　进程实体包括程序进程控制块（Process Control Block, PCB）、程序段、进程段。</p><h4 id="1-2-1-PCB"><a href="#1-2-1-PCB" class="headerlink" title="1.2.1 PCB"></a>1.2.1 PCB</h4><p>　　系统为运行的程序配置一个数据结构，叫做进程控制块。它用来存储进程的各种信息（如程序代码的存放位置）。<br>　　创建进程实质上式创建进程实体中的PCB；撤销进程实质上是撤销PCB。<strong>PCB是进程的存在的唯一标志！</strong></p><h3 id="1-3-进程："><a href="#1-3-进程：" class="headerlink" title="1.3 进程："></a>1.3 进程：</h3><p>　　下面三个定义取自王道考研《操作系统》，本人偏爱第三个，但它们都强调了进程的动态性（即进程是一个过程）。</p><ul><li>进程是程序的一次<strong>执行过程</strong>。</li><li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong>。</li><li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，它是系统进行资源分配和调度的一个独立单位。</li></ul><h4 id="1-3-1-为什么引入进程实体和进程？"><a href="#1-3-1-为什么引入进程实体和进程？" class="headerlink" title="1.3.1 为什么引入进程实体和进程？"></a>1.3.1 为什么引入进程实体和进程？</h4><p>　　在单道机处理系统中，计算机只能处理一道程序，该程序独占计算机（包含IO等其他资源）。而在引入多道程序技术后，计算机需要考虑如何分配资源，为了方便操作系统管理，因此引入了进程实体和进程两个概念。　</p><h4 id="1-3-2-进程与进程实体的区别"><a href="#1-3-2-进程与进程实体的区别" class="headerlink" title="1.3.2 进程与进程实体的区别"></a>1.3.2 进程与进程实体的区别</h4><ul><li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</li><li>进程和进程实体并不一样，进程是动态的，进程实体是静态的。</li><li>如果不要求严谨，也可以认为进程实体就是进程。</li></ul><h3 id="1-4-线程："><a href="#1-4-线程：" class="headerlink" title="1.4 线程："></a>1.4 线程：</h3><p>　　线程是轻量级进程。</p><h4 id="1-4-1-为什么引入线程？"><a href="#1-4-1-为什么引入线程？" class="headerlink" title="1.4.1 为什么引入线程？"></a>1.4.1 为什么引入线程？</h4><p>　　有的进程需要同时处理很多事情，而传统进程只能串行的执行一系列程序，为此，引入线程来提高<strong>并发度</strong>。<br>　　引入线程后，线程成为程序执行流的最小单位</p><h2 id="2-threading库"><a href="#2-threading库" class="headerlink" title="2 threading库"></a>2 threading库</h2><h3 id="2-1-利用Thread类创建线程"><a href="#2-1-利用Thread类创建线程" class="headerlink" title="2.1 利用Thread类创建线程"></a>2.1 利用Thread类创建线程</h3><p>&lt;代码示例1&gt;<a name="代码示例1"></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># author: HuXiaoming</span><br><span class="hljs-comment"># date: 2021-4-9</span><br><span class="hljs-comment"># using:</span><br><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startMove</span>(<span class="hljs-params">action: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行&quot;</span> + action + <span class="hljs-string">&quot;动作，进度为&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;%&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createThread</span>() -&gt; <span class="hljs-literal">None</span>:</span><br>    <span class="hljs-comment"># walk_ 用来与walk做区分</span><br>    actions = [<span class="hljs-string">&quot;walk&quot;</span>, <span class="hljs-string">&quot;turn left&quot;</span>, <span class="hljs-string">&quot;walk_&quot;</span>]<br><br>    <span class="hljs-comment"># 创建三个动作线程</span><br>    thread1 = Thread(target=startMove, args=(actions[<span class="hljs-number">0</span>], ))<br>    thread2 = Thread(target=startMove, args=(actions[<span class="hljs-number">1</span>], ))<br>    thread3 = Thread(target=startMove, args=(actions[<span class="hljs-number">2</span>], ))<br><br>    <span class="hljs-comment"># 调用start()函数，新的线程才创建成功，并开始执行入口函数 startMove 里面的代码。</span><br>    thread1.start()<br>    thread2.start()<br>    thread3.start()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    createThread()<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/result1.png"></p><p>分析：</p><p>　　<strong>可见walk动作在执行到进度70%的时候被turn left动作抢占。</strong>如果想让执行顺序为”walk -&gt; turn left -&gt; walk_“，需要使用Lock进行互斥访问，见<a href="#2.3%E4%BA%92%E6%96%A5%E9%94%81">2.3</a>节。</p><h3 id="2-2-Thread类的封装"><a href="#2-2-Thread类的封装" class="headerlink" title="2.2 Thread类的封装"></a>2.2 Thread类的封装</h3><p>　　一开始我不理解既然有<a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B1">&lt;代码示例1&gt;</a>中18到20行所示的创建Thread对象的方法，为什么还要自己创建新的继承自Thread类的多线程类。这其实就是一种封装的思想，我们可以把一些功能写在这个新建的多线程类中（如：打印提示线程的创建）。<br>　　下面以my_thread.py为例进行介绍Thread类的封装。<br>&lt;代码示例2&gt;<a name="代码示例2"></a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># my_thread.py</span><br><span class="hljs-comment"># author: HuXiaoming</span><br><span class="hljs-comment"># date: 2021-4-9</span><br><span class="hljs-comment"># using:</span><br><br><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-keyword">from</span> demo.first_thread <span class="hljs-keyword">import</span> startMove<br><br>actions = [<span class="hljs-string">&quot;walk&quot;</span>, <span class="hljs-string">&quot;turn left&quot;</span>, <span class="hljs-string">&quot;walk_&quot;</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span>(<span class="hljs-params">Thread</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, action: <span class="hljs-built_in">str</span>, threadID: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.action = action<br>        self.threadID = threadID<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;动作线程创立，线程ID为&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(self.action, self.threadID))<br><br>    <span class="hljs-comment"># start()就会调用run()函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======开始执行&#123;&#125;动作======&quot;</span>.<span class="hljs-built_in">format</span>(self.action))<br>        startMove(self.action)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;======&#123;&#125;动作执行结束======&quot;</span>.<span class="hljs-built_in">format</span>(self.action))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions:<br>        myT = MyThread(action, i)<br>        myT.start()<br>        i += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/result2.png"></p><h3 id="2-3-互斥锁"><a href="#2-3-互斥锁" class="headerlink" title="2.3 互斥锁"></a>2.3 互斥锁<a name="2.3互斥锁"></a></h3><p>常用函数：</p><ol><li>Lock( ).acquire( )：请求；相当操作系统中的wait( )或者P操作。</li><li>Lock( ).release( )： 释放；相当操作系统中的signal( )或者V操作。</li><li>Lock( ).locked( )：判断是否被锁</li></ol><p>&lt;代码示例3&gt;：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># Author: HuXiaoming</span><br><span class="hljs-comment"># Date: 2021-4-21</span><br><span class="hljs-comment"># using: Lock锁</span><br><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock<br><br>mutex = Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startMove</span>(<span class="hljs-params">action: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>    mutex.acquire()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">101</span>, <span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在执行&quot;</span> + action + <span class="hljs-string">&quot;动作，进度为&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;%&quot;</span>)<br>    mutex.release()<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createThread</span>() -&gt; <span class="hljs-literal">None</span>:</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程开始！&quot;</span>)<br><br>    <span class="hljs-comment"># walk_ 用来与walk做区分</span><br>    actions = [<span class="hljs-string">&quot;walk&quot;</span>, <span class="hljs-string">&quot;turn left&quot;</span>, <span class="hljs-string">&quot;walk_&quot;</span>]<br><br>    <span class="hljs-comment"># 创建三个动作线程</span><br>    thread1 = Thread(target=startMove, args=(actions[<span class="hljs-number">0</span>], ))<br>    thread2 = Thread(target=startMove, args=(actions[<span class="hljs-number">1</span>], ))<br>    thread3 = Thread(target=startMove, args=(actions[<span class="hljs-number">2</span>], ))<br><br>    thread_list = [thread1, thread2, thread3]<br><br>    <span class="hljs-comment"># 调用start()函数，新的线程才创建成功，并开始执行入口函数 startMove 里面的代码。</span><br>    thread1.start()<br>    thread2.start()<br>    thread3.start()<br><br>    <span class="hljs-comment"># 让主线程等待三个子程序结束后在结束</span><br>    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> thread_list:<br>        thread.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程结束！&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    createThread()<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2021/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/result3.png"></p><p>分析：</p><p>　　成功按顺序执行。在<a href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B2">&lt;代码示例2&gt;</a>中可以将Lock对象封装在run函数里。</p><h2 id="3-queue库"><a href="#3-queue库" class="headerlink" title="3 queue库"></a>3 queue库</h2><h2 id="4-队列与线程的结合"><a href="#4-队列与线程的结合" class="headerlink" title="4 队列与线程的结合"></a>4 队列与线程的结合</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>王道考研《操作系统》</li><li>白月黑羽.python进阶.<a href="http://www.python3.vip/tut/py/extra/multi_thread/">多线程和多进程</a></li><li>Python官方文档.<a href="https://docs.python.org/zh-cn/3.7/library/threading.html?highlight=threading#threading.Thread.daemon">threading—基于线程的并发</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第17章 贪婪算法</title>
    <link href="/2021/04/06/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/06/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="第17章-贪婪算法"><a href="#第17章-贪婪算法" class="headerlink" title="第17章 贪婪算法"></a>第17章 贪婪算法</h1><h2 id="1-概念先行"><a href="#1-概念先行" class="headerlink" title="1 概念先行"></a>1 概念先行</h2><ol><li>最优化问题：包含限制条件和优化函数</li><li><strong>可行解</strong>：符合限制条件的问题求解方案</li><li>最优解：使优化函数可能取得最佳值的可行解</li></ol><h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2 应用"></a>2 应用</h2><h3 id="2-1-渴婴问题-例17-1"><a href="#2-1-渴婴问题-例17-1" class="headerlink" title="2.1 渴婴问题[例17-1]"></a>2.1 渴婴问题[例17-1]</h3><h3 id="2-2-装载问题-例17-2"><a href="#2-2-装载问题-例17-2" class="headerlink" title="2.2 装载问题[例17-2]"></a>2.2 装载问题[例17-2]</h3><h3 id="2-3-最小成本通信网络-例17-3"><a href="#2-3-最小成本通信网络-例17-3" class="headerlink" title="2.3 最小成本通信网络[例17-3]"></a>2.3 最小成本通信网络[例17-3]</h3><h3 id="2-4-找零钱-例17-4"><a href="#2-4-找零钱-例17-4" class="headerlink" title="2.4 找零钱[例17-4]"></a>2.4 找零钱[例17-4]</h3><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>小孩用1美元来买价值不足1美元的糖果，售货员希望用最少的硬币来找钱。硬币有25美分、10美分、5美分及1美分的硬币，而且数目不限。售货员每次选择一枚硬币，凑成要找的零钱。选择时采用贪心准则（<strong>本题是最能体现贪心思想的，为了给顾客数量最少的硬币，我们先选用大面值的硬币，然后次一点，然后再次一点的，直到完成找零任务</strong>）。直到凑成的零钱总数等于要找的零钱数。</p><h4 id="证明-练习17-1-："><a href="#证明-练习17-1-：" class="headerlink" title="证明[练习17-1]："></a>证明[练习17-1]：</h4><p>售货员只要有足够的硬币，使用找零问题的贪心算法，总能凑出硬币最少的零钱。<br>证明（假设法）：</p><ul><li>采用贪心算法得到的方案为用$[n_1, n_2, n_3, n_4]$个[25美分, 10美分, 5美分, 1美分]来找零，假设该方案不是最优解；</li><li>用2个10美分和1个五美分来代替1个25美分，方案变为$[n_1-1, n_2+2, n_3+1, n_4]$；</li><li>显然新方案中的硬币数变多了（如果其他面值小于25美分的来代替一个25美分，硬币增加的数量会更多）；</li><li>所以原方案为最优解，假设不成立。</li></ul>]]></content>
    
    
    <categories>
      
      <category>《数据结构、算法与应用 C++描述》</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第1章 C++回顾</title>
    <link href="/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-C-回顾"><a href="#第1章-C-回顾" class="headerlink" title="第1章 C++回顾"></a>第1章 C++回顾</h1><h2 id="1-7-递归函数"><a href="#1-7-递归函数" class="headerlink" title="1.7 递归函数"></a>1.7 递归函数</h2><h3 id="练习-24"><a href="#练习-24" class="headerlink" title="练习 24"></a>练习 24</h3><div class="note note-info">            <p><strong>题目：</strong></p><p>编写一个递归模板函数，确定元素x是否属于数组a[0: n-1]。</p>          </div><p>&lt;代码清单 #1&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 24.</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_for_x_in_array_a</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T a[], <span class="hljs-keyword">const</span> T x, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt; end)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> middle = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>((start + end) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(a[middle] == x)<br>            <span class="hljs-keyword">return</span> middle;<br>        <span class="hljs-comment">// cout &lt;&lt; middle &lt;&lt; endl;</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> index = <span class="hljs-built_in">search_for_x_in_array_a</span>(a, x, start, middle<span class="hljs-number">-1</span>);<br>            <span class="hljs-comment">// cout &lt;&lt; endl &lt;&lt; middle &lt;&lt; endl;</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>) <span class="hljs-comment">// 关键</span><br>                <span class="hljs-built_in">search_for_x_in_array_a</span>(a, x, middle+<span class="hljs-number">1</span>, end);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试24</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_search_x</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">45</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-keyword">int</span> a_x = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//int a_x = 10;</span><br><br>    <span class="hljs-keyword">char</span> b[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br>    <span class="hljs-keyword">char</span> b_x = <span class="hljs-string">&#x27;w&#x27;</span>;<br>    <span class="hljs-comment">//char b_x = &#x27;e&#x27;;</span><br>    cout &lt;&lt; a_x &lt;&lt; <span class="hljs-string">&quot;在数组a中的下标为：&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">search_for_x_in_array_a</span>(a, a_x, <span class="hljs-number">0</span>, <span class="hljs-number">6</span><span class="hljs-number">-1</span>);<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; b_x &lt;&lt; <span class="hljs-string">&quot;在数组b中的下标为：&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">search_for_x_in_array_a</span>(b, b_x, <span class="hljs-number">0</span>, <span class="hljs-number">6</span><span class="hljs-number">-1</span>);<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">test_search_x</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p><strong>方法：</strong></p><p>我编写的是一个查找无序数组的递归版查找法。不同于折半查找的是，在一般情况下，程序将middle的两边都搜索一下，除非在middle的前面就遇到了待查元素，如数组a所示。</p>          </div><p>search函数在数组a中查找x的步骤如下图所示：</p><p><img src="/2021/04/04/C,C++%E5%9B%9E%E9%A1%BE/%E9%80%92%E5%BD%92.jpg" alt="图1 本题递归树示意图"></p><div class="note note-danger">            <p><strong>问题：</strong></p><p>一开始没有第20行，导致查找结果一直为-1。</p>          </div><div class="note note-success">            <p><strong>原因：</strong></p><p>查找结束时，递归函数返回上一层，不会中断（跳出所有的递归层）。又因为没有20行的if语句判断，故当前层的递归函数向下继续运行。</p><p><strong>解决办法：</strong></p><p>在20行加上if判断</p>          </div><h3 id="练习-25"><a href="#练习-25" class="headerlink" title="练习 25"></a>练习 25</h3><div class="note note-info">            <p><strong>题目：</strong>[子集生成方法（Subset Generation）] </p><p>编写一个C++递归函数，输出n个元素的所有子集。例如，三元素集{a,b,c}的子集是{}（空集）,{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}。这些子集用0/1组成的代码序列来表示分别是000,100,010,001,110,101,011,111(0表示相应的元素不在子集中，1表示相应的元素在子集中)。因此你的程序输出长度为n的0/1序列即可。</p>          </div><p>&lt;代码清单 #2&gt;<a name="代码清单2"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span> <span class="hljs-comment">// pow(double base, double exp)</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 25. 子集生成方法</span><br><span class="hljs-keyword">int</span> sequence[<span class="hljs-number">10000</span>][<span class="hljs-number">10000</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subset_generation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<span class="hljs-comment">// 空集的子集只有空集</span><br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">1</span>; i ++)<br>            sequence[i][<span class="hljs-number">1</span>] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> row_length = <span class="hljs-built_in">subset_generation</span>(n<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> cur_row_length = <span class="hljs-number">2</span> * row_length;<br>        <span class="hljs-comment">// 拷贝两遍 n-1 个元素的信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = row_length; row &lt; cur_row_length; row ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">1</span>; col &lt;= n<span class="hljs-number">-1</span>; col ++)<br>                    sequence[row][col] = sequence[row-row_length][col];<br>        <span class="hljs-comment">// 添加第 n 个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; cur_row_length; row ++)<br>            sequence[row][n] = row &lt; row_length? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> cur_row_length;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">subset_generation_with_non_recursive_funcation</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 转二进制</span><br>    <span class="hljs-keyword">int</span> subset[n] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// n 位二进制转其能表示的最大十进制</span><br>    <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i --)<br>        number += <span class="hljs-built_in">pow</span>(<span class="hljs-number">2.0</span>, i);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= number; i ++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> temp_n = n;<br>        <span class="hljs-keyword">int</span> temp_i = i;<br>        <span class="hljs-keyword">while</span>(temp_i &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            subset[temp_n<span class="hljs-number">-1</span>] = temp_i % <span class="hljs-number">2</span>;<br>            temp_i /= <span class="hljs-number">2</span>;<br>            temp_n --;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            cout &lt;&lt; subset[j];<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 测试25</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_subset_generation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// n must lower than seven</span><br>    <span class="hljs-comment">// int n = 10;</span><br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">time_t</span> start_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// cout &lt;&lt; start_time &lt;&lt; endl;</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;all subsets are:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-built_in">subset_generation</span>(n);<br>    <span class="hljs-keyword">if</span> (length &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i ++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)<br>            cout &lt;&lt; sequence[i][j];<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">time_t</span> end_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; end_time - start_time &lt;&lt; endl;<br>    start_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;with non-recursive_way, all subsets are:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">subset_generation_with_non_recursive_funcation</span>(n);<br>    end_time = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; end_time - start_time &lt;&lt; endl;<br>    <span class="hljs-comment">// 经测试，递归快一点</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">test_subset_generation</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>递归法</li></ol><ul><li>当 n = 0 时，即该 n 元素集为空集， 空集的子集只有一个空集，故输出为 0。</li><li>当 n = 1 时，即 1 元素集，比如{ a }，它有两个子集{ }， { a }， 故输出为 0、1。</li><li>当 n = 2 时，即 2 元素集，比如{ a, b }，它有四个子集{ }， { a }，{ b }，{ a，b}，故输出为 00、10、 01、 11。</li><li>…………</li></ul><p>下面我们用表格来表示一下规律。</p><table width="400" height="150">    <caption align="top">表1 n=1</caption>    <tr>        <td>0</td>    </tr>    <tr>        <td>1</td>    </tr></table><blockquote><p>如何由表 1 推到表 2：<br>第1步：将表 1 拷贝两遍，形成表 2 的蓝色区域。<br>第2步：将第二个元素的两种取值（0,1）插入表 2， 如表 2 绿色区域所示。</p></blockquote><table width="400" height="150">  <caption align="top">表2 n=2</caption>  <tr>    <td style="background-color: blue">0</td>    <td style="background-color: green">0</td>  </tr>  <tr>    <td style="background-color: blue">1</td>    <td style="background-color: green">0</td>  </tr>  <tr>    <td style="background-color: blue">0</td>    <td style="background-color: green">1</td>  </tr>  <tr>    <td style="background-color: blue">1</td>    <td style="background-color: green">1</td>  </tr></table><blockquote><p>表 2 推表 3 的步骤与表 1 推表 2 的步骤相同。</p></blockquote><table width="400" height="150">  <caption align="top">表3 n=3</caption>  <tr>    <td style="background-color: blue">0</td>    <td style="background-color: blue">0</td>    <td style="background-color: green">0</td>  </tr>  <tr>    <td style="background-color: blue">1</td>    <td style="background-color: blue">0</td>    <td style="background-color: green">0</td>  </tr>  <tr>    <td style="background-color: blue">0</td>    <td style="background-color: blue">1</td>    <td style="background-color: green">0</td>  </tr>  <tr>    <td style="background-color: blue">1</td>    <td style="background-color: blue">1</td>    <td style="background-color: green">0</td>  </tr>  <tr>    <td style="background-color: blue">0</td>    <td style="background-color: blue">0</td>    <td style="background-color: green">1</td>  </tr>  <tr>    <td style="background-color: blue">1</td>    <td style="background-color: blue">0</td>    <td style="background-color: green">1</td>  </tr>  <tr>    <td style="background-color: blue">0</td>    <td style="background-color: blue">1</td>    <td style="background-color: green">1</td>  </tr>  <tr>    <td style="background-color: blue">1</td>    <td style="background-color: blue">1</td>    <td style="background-color: green">1</td>  </tr></table><p>　　上述的表 1 到 表 3 是即为程序中第7行的sequence数组，它采用二维表格存储结果。</p><ol start="2"><li>二进制法<br>见<a href="#%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%952">&lt;代码清单2&gt;</a>第37行函数<code>void subset_generation_with_non_recursive_funcation(const int n)</code></li></ol><h3 id="代码汇总"><a href="#代码汇总" class="headerlink" title="代码汇总"></a>代码汇总</h3><p>　　1.7节课后练习全部代码见<a href="https://github.com/Hu-Xiaoming/code/tree/main/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8%20C%2B%2B%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8B/chapter_1/section_1.7">github地址</a></p>]]></content>
    
    
    <categories>
      
      <category>《数据结构、算法与应用 C++描述》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资料补给站</title>
    <link href="/2021/04/04/%E8%B5%84%E6%96%99%E8%A1%A5%E7%BB%99%E7%AB%99/"/>
    <url>/2021/04/04/%E8%B5%84%E6%96%99%E8%A1%A5%E7%BB%99%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机学习资料"><a href="#计算机学习资料" class="headerlink" title="计算机学习资料"></a>计算机学习资料</h1><h2 id="语言篇"><a href="#语言篇" class="headerlink" title="语言篇"></a>语言篇</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><ul><li><a href="http://www.cplusplus.com/">http://www.cplusplus.com/</a></li><li>MFC：<a href="http://www.jizhuomi.com/software/257.html">http://www.jizhuomi.com/software/257.html</a></li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><ul><li>python官方文档：<a href="https://docs.python.org/zh-cn/3.7/tutorial/index.html">https://docs.python.org/zh-cn/3.7/tutorial/index.html</a></li><li>Dive into python（深入python）：<a href="https://diveintopython3.net/">https://diveintopython3.net/</a></li><li><a href="http://www.python3.vip/">http://www.python3.vip/</a></li></ul><h2 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h2><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><ul><li>数据结构、算法与应用(c++)<a href="https://www.cise.ufl.edu/~sahni/dsaac/">https://www.cise.ufl.edu/~sahni/dsaac/</a></li></ul><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul><li><a href="http://www.songho.ca/math/index.html">http://www.songho.ca/math/index.html</a></li><li>wolfram mathworld（用于查询）：<a href="https://mathworld.wolfram.com/topics/">https://mathworld.wolfram.com/topics/</a></li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><h4 id="机器学习-1"><a href="#机器学习-1" class="headerlink" title="机器学习"></a>机器学习</h4><ul><li>南瓜书：<a href="https://datawhalechina.github.io/pumpkin-book/#/">https://datawhalechina.github.io/pumpkin-book/#/</a><br>【注】：南瓜书是对西瓜书（周志华《机器学习》）中公式的详尽推导</li><li>scikit-learn: <a href="https://scikit-learn.org/stable/">https://scikit-learn.org/stable/</a></li></ul><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><ul><li><p>david silver：<a href="https://www.davidsilver.uk/teaching/">https://www.davidsilver.uk/teaching/</a></p></li><li><p>莫烦python：<a href="https://morvanzhou.github.io/">https://morvanzhou.github.io/</a></p><p>【注】：也包含python、深度学习、实例、多进程等等。</p></li></ul><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><ul><li>动手学深度学习：<ul><li>文档：<a href="http://zh.gluon.ai/">http://zh.gluon.ai/</a></li><li>视频：<a href="https://www.bilibili.com/video/BV154411S7Tf?from=search&amp;seid=9397274944264794167">https://www.bilibili.com/video/BV154411S7Tf?from=search&amp;seid=9397274944264794167</a></li></ul></li></ul><h4 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h4><ul><li>HanLP：<ul><li>PyHanLP工具包使用指南：<a href="https://ningshixian.github.io/2019/11/13/PyHanLP%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">https://ningshixian.github.io/2019/11/13/PyHanLP%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</a></li></ul></li></ul><h4 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h4><ul><li>人工智能：<a href="https://www.captainai.net/st/">https://www.captainai.net/st/</a></li></ul><h2 id="操作系统篇"><a href="#操作系统篇" class="headerlink" title="操作系统篇"></a>操作系统篇</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li>鸟哥的Linux私房菜：<a href="http://linux.vbird.org/">http://linux.vbird.org/</a></li><li>Makefile<ul><li><a href="https://seisman.github.io/how-to-write-makefile/invoke.html">https://seisman.github.io/how-to-write-makefile/invoke.html</a></li></ul></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="微软官方文档-包含c-，sql等等"><a href="#微软官方文档-包含c-，sql等等" class="headerlink" title="微软官方文档(包含c++，sql等等)"></a>微软官方文档(包含c++，sql等等)</h3><ul><li>MSDN：<a href="https://docs.microsoft.com/zh-cn/">https://docs.microsoft.com/zh-cn/</a><h3 id="OI-Wiki"><a href="#OI-Wiki" class="headerlink" title="OI Wiki"></a>OI Wiki</h3></li><li>OI Wiki：<a href="https://oi-wiki.org/">https://oi-wiki.org/</a></li></ul><h1 id="绘画学习资料"><a href="#绘画学习资料" class="headerlink" title="绘画学习资料"></a>绘画学习资料</h1><h2 id="素材篇"><a href="#素材篇" class="headerlink" title="素材篇"></a>素材篇</h2><ul><li><a href="https://line-of-action.com/practice-tools/">https://line-of-action.com/practice-tools/</a></li><li>不移之火：<a href="https://www.byzhihuo.com/">https://www.byzhihuo.com</a></li></ul><h2 id="喜欢的画家"><a href="#喜欢的画家" class="headerlink" title="喜欢的画家"></a>喜欢的画家</h2><ul><li>意大利画师mauro belfiore：<a href="https://cn.bing.com/search?q=mauro+belfiore&amp;FORM=HDRSC1">https://cn.bing.com/search?q=mauro+belfiore&amp;FORM=HDRSC1</a></li></ul><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="国学"><a href="#国学" class="headerlink" title="国学"></a>国学</h2><ul><li>国学导航：<a href="http://www.guoxue123.com/index.htm">http://www.guoxue123.com/index.htm</a></li><li>地图：<a href="http://www.guoxue123.com/other/map/zgmap/index.htm?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=603304426711158784">http://www.guoxue123.com/other/map/zgmap/index.htm?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=603304426711158784</a></li><li>书格（古籍）： <a href="https://new.shuge.org/">https://new.shuge.org</a> </li></ul><h2 id="图片素材网站"><a href="#图片素材网站" class="headerlink" title="图片素材网站"></a>图片素材网站</h2><ul><li>pexels：<a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a></li><li>Wallhaven：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a></li><li>Wallpaper Hub：<a href="https://wallpaperhub.app/">https://wallpaperhub.app/</a></li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>代码高亮（菜鸟）：<a href="https://c.runoob.com/front-end/5536">https://c.runoob.com/front-end/5536</a></li><li>PDF转化：<a href="https://xpdf.net/pdf-to-word">https://xpdf.net/pdf-to-word</a></li><li>在线域名解析器：<a href="http://www.ip33.com/dns.html">http://www.ip33.com/dns.html</a></li><li>流程图：<a href="https://online.visual-paradigm.com/cn/diagrams/features/flowchart-tool/">https://online.visual-paradigm.com/cn/diagrams/features/flowchart-tool/</a></li><li>github：<a href="https://docs.github.com/cn">https://docs.github.com/cn</a></li><li>桌面管理（酷呆桌面）：<a href="https://www.coodesker.com/">https://www.coodesker.com/</a></li><li>阿里巴巴矢量图标库：<a href="https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a">https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
